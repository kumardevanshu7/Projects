<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PriorityHelp AI - Task Manager</title>
    <link
      rel="shortcut icon"
      href="https://shorturl.at/cQmMr"
      type="image/x-icon"
    />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Caveat:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <!-- Font Awesome CDN -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />

    <!-- SweetAlert2 removed for faster experience -->
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <!-- Core Animation Libraries (Used Actively) -->
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/typed.js/2.0.12/typed.min.js"></script>

    <!-- jQuery (required by some plugins below) -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tilt.js/1.2.1/tilt.jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lettering.js/0.7.0/jquery.lettering.min.js"></script>

    <!-- Other Requested Libraries (CDNs included, placeholders for integration) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vivus/0.4.6/vivus.min.js"></script>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/css/lightbox.min.css"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/js/lightbox.min.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/swiper/swiper-bundle.min.css"
    />
    <script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/picturefill/3.0.3/picturefill.min.js"></script>

    <style>
      :root {
        /* New UI Theme Colors (Inspired by "Plantitas" UI Kit) */
        --ph-new-bg-page: #f3f5f0; /* Light desaturated green/beige page background */
        --ph-new-white: #ffffff;
        --ph-new-dark-green: #253528;
        --ph-new-medium-green: #49654e;
        --ph-new-light-green: #8ba889;
        --ph-new-soft-green-bg: #e9efe8; /* For column backgrounds or subtle highlights */

        --ph-new-text-dark: var(--ph-new-dark-green);
        --ph-new-text-medium: var(--ph-new-medium-green);
        --ph-new-text-light-on-dark: var(--ph-new-white);
        --ph-new-text-placeholder: #a0a0a0;

        --ph-new-border-color: #dce1da; /* Softer border color */
        --ph-new-shadow: 0 5px 15px rgba(0, 0, 0, 0.05); /* Softer shadow */
        --ph-new-shadow-hover: 0 8px 25px rgba(0, 0, 0, 0.08); /* Hover shadow */

        /* Primary Font */
        --font-primary: "Poppins", sans-serif;

        /* Fallback to new names for clarity, old names can be phased out */
        --bg-cream: var(--ph-new-bg-page);
        --card-bg: var(--ph-new-white);
        --text-primary: var(--ph-new-text-dark);
        --text-secondary: var(--ph-new-text-medium);
        --border-color: var(--ph-new-border-color);

        /* Accent colors for charts/icons (can be from new greens or complementary) */
        --accent-blue: #7ba0c9; /* Softer blue */
        --accent-red: #d48484; /* Softer red */
        --accent-yellow: #e6c57f; /* Softer yellow */
        --accent-purple: #a98abe; /* Softer purple */
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: var(--font-primary);
        background-color: var(--ph-new-bg-page);
        color: var(--ph-new-text-dark);
        line-height: 1.6;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        padding: 20px;
        overflow-x: hidden;
      }

      #particles-js {
        position: fixed;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        z-index: -1;
        background-color: var(--ph-new-bg-page);
      }

      .main-app-layout {
        width: 100%;
        max-width: 1320px; /* Wider max width for desktop */
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        min-height: calc(100vh - 40px); /* body padding * 2 */
        position: relative;
        z-index: 1;
      }

      .content-wrapper-card {
        background-color: var(--ph-new-white);
        border-radius: 24px; /* Consistent rounding */
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.06); /* Slightly more pronounced shadow */
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        position: relative;
        overflow: hidden;
        padding: 0;
      }

      .dark-organic-shape-element,
      .deco-leaf {
        display: none !important;
      }

      .app-header-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 25px; /* Reduced horizontal padding slightly */
        border-bottom: 1px solid var(--ph-new-border-color);
        position: relative;
        z-index: 10;
        gap: 15px; /* Added gap for better spacing when items are closer */
      }

      .header-title-section {
        display: flex;
        align-items: center;
      }
      .header-title-section .logo-placeholder {
        width: 38px;
        height: 38px;
        border-radius: 10px;
        margin-right: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        overflow: hidden;
      }

      .header-title-section .logo-placeholder img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 10px;
      }
      .header-title-section h1#animated-logo-title {
        font-family: var(--font-primary);
        font-size: 1.4em; /* Slightly reduced */
        font-weight: 600;
        color: var(--ph-new-text-dark);
        margin-right: 0;
        min-width: fit-content;
      }
      .header-center-section {
        flex-grow: 1;
        display: flex;
        justify-content: center;
        min-width: 0; /* Allow shrinking */
      }

      .header-nav {
        display: flex;
        align-items: center;
        gap: 15px; /* Reduced gap */
        flex-shrink: 0;
      }
      .header-nav a,
      .behaviour-analysis-btn-nav {
        font-family: var(--font-primary);
        font-size: 0.85em; /* Slightly reduced */
        color: var(--ph-new-text-medium);
        text-decoration: none;
        transition: color 0.2s ease, background-color 0.2s ease;
        font-weight: 500;
        padding: 6px 10px; /* Adjusted padding */
        border-radius: 6px;
        white-space: nowrap; /* Prevent button text from wrapping easily */
      }
      .header-nav a:hover,
      .behaviour-analysis-btn-nav:hover {
        color: var(--ph-new-text-dark);
        background-color: var(--ph-new-soft-green-bg);
      }
      .behaviour-analysis-btn-nav {
        background: none;
        border: none;
        cursor: pointer;
      }
      .header-info-icon {
        font-size: 1.1em;
        color: var(--ph-new-text-medium);
        cursor: pointer;
        padding: 8px;
        border-radius: 6px;
        transition: color 0.2s ease, background-color 0.2s ease;
      }
      .header-info-icon:hover {
        color: var(--ph-new-text-dark);
        background-color: var(--ph-new-soft-green-bg);
      }

      .date-controls {
        display: flex;
        align-items: center;
        color: var(--ph-new-text-medium);
      }
      .date-controls i {
        /* For prev/next arrows and calendar icon */
        margin: 0 8px; /* Consistent margin */
        cursor: pointer;
        transition: color 0.2s ease, transform 0.2s ease;
        font-size: 0.9em; /* Slightly smaller icons */
        color: var(--ph-new-text-medium);
      }
      .date-controls i:hover {
        color: var(--ph-new-text-dark);
        transform: scale(1.05);
      }
      #current-date-display {
        /* Minimal date display */
        padding: 7px 10px;
        border-radius: 8px;
        font-size: 0.85em;
        background-color: transparent;
        color: var(--ph-new-text-dark);
        min-width: 120px; /* Adjust as needed */
        text-align: center;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      #current-date-display:hover {
        background-color: var(--ph-new-soft-green-bg);
      }
      #current-date-input {
        /* Style for the native date input when visible */
        padding: 6px 9px;
        border: 1px solid var(--ph-new-border-color);
        border-radius: 8px;
        font-size: 0.85em;
        background-color: var(--ph-new-white);
        color: var(--ph-new-text-dark);
        color-scheme: light; /* Ensures dark text on light background for date picker */
        /* margin-left: 7px; No margin needed if it replaces display */
      }
      #current-date-input.hidden {
        display: none !important;
      }

      .app-content-area {
        padding: 30px 35px;
        flex-grow: 1;
        overflow-y: auto;
        position: relative;
        z-index: 5;
      }
      .hidden {
        display: none !important;
      }

      .hero-intro-section {
        padding: 25px 0;
        margin-bottom: 35px;
        max-width: 100%;
        text-align: left;
      }
      .hero-subtitle {
        font-family: var(--font-primary);
        font-size: 0.85em;
        font-weight: 500;
        color: var(--ph-new-medium-green);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
      }
      .hero-title {
        font-family: var(--font-primary);
        font-size: 2em;
        font-weight: 600;
        color: var(--ph-new-text-dark);
        line-height: 1.3;
        margin-bottom: 15px;
        min-height: 52px; /* For Typed.js */
      }
      .hero-description {
        font-family: var(--font-primary);
        font-size: 0.95em;
        color: var(--ph-new-text-medium);
        line-height: 1.6;
        margin-bottom: 25px;
        max-width: 600px;
      }
      .hero-buttons {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .hero-cta-button,
      .hero-secondary-button {
        border: none;
        padding: 12px 28px;
        border-radius: 8px;
        font-size: 0.95em;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.2s ease,
          box-shadow 0.2s ease;
        display: inline-flex;
        align-items: center;
        box-shadow: 0 3px 10px rgba(37, 53, 40, 0.2);
      }
      .hero-cta-button {
        background-color: var(--ph-new-dark-green);
        color: var(--ph-new-white);
      }
      .hero-secondary-button {
        background-color: var(--ph-new-white);
        color: var(--ph-new-dark-green);
        border: 2px solid var(--ph-new-medium-green);
        box-shadow: 0 3px 10px rgba(37, 53, 40, 0.1);
      }
      .hero-cta-button i,
      .hero-secondary-button i {
        margin-right: 8px;
        font-size: 1em;
      }
      .hero-cta-button:hover {
        background-color: var(--ph-new-medium-green);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(37, 53, 40, 0.25);
      }
      .hero-secondary-button:hover {
        background-color: var(--ph-new-light-green);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(37, 53, 40, 0.2);
      }

      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(37, 53, 40, 0.6);
        backdrop-filter: blur(6px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }
      .modal-overlay.visible {
        opacity: 1;
        visibility: visible;
      }
      .modal-content {
        background-color: var(--ph-new-white);
        padding: 30px 35px;
        border-radius: 16px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        width: 90%;
        max-width: 550px;
        border: 1px solid var(--ph-new-border-color);
        transform: translateY(30px) scale(0.95);
        opacity: 0;
        transition: transform 0.35s ease, opacity 0.35s ease;
      }
      .modal-overlay.visible .modal-content {
        /* GSAP will handle this primarily but good fallback */
        transform: translateY(0) scale(1);
        opacity: 1;
      }
      .modal-content h2 {
        margin-bottom: 18px;
        font-size: 1.6em;
        color: var(--ph-new-text-dark);
        text-align: center;
        font-weight: 600;
        font-family: var(--font-primary);
      }
      #greeting-message-modal {
        font-size: 0.9em;
        margin-bottom: 20px;
        color: var(--ph-new-text-medium);
        text-align: center;
      }
      #task-input-field-modal {
        width: 100%;
        padding: 14px;
        border: 1px solid var(--ph-new-border-color);
        border-radius: 8px;
        font-size: 1em;
        margin-bottom: 18px;
        background-color: var(--ph-new-soft-green-bg);
        color: var(--ph-new-text-dark);
      }
      #task-input-field-modal::placeholder {
        color: var(--ph-new-text-placeholder);
      }
      #task-input-field-modal:focus {
        outline: none;
        border-color: var(--ph-new-medium-green);
        box-shadow: 0 0 0 3px rgba(73, 101, 78, 0.15);
        background-color: var(--ph-new-white);
      }
      #current-tasks-list-modal div {
        padding: 9px 14px;
        background-color: var(--ph-new-soft-green-bg);
        border-radius: 6px;
        margin-bottom: 8px;
        font-size: 0.9em;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border: 1px solid #dde2dc;
        color: var(--ph-new-text-medium);
      }
      #current-tasks-list-modal i {
        color: var(--accent-red);
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      #current-tasks-list-modal i:hover {
        transform: scale(1.1);
      }
      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        margin-top: 25px;
      }
      .modal-actions .button-style {
        margin-top: 0;
        padding: 10px 22px;
        font-size: 0.9em;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        transition: all 0.2s ease-out;
        font-weight: 500;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
      }
      #cancel-add-task-btn,
      #info-modal-close-btn {
        background-color: var(--ph-new-soft-green-bg);
        color: var(--ph-new-text-medium);
        border: 1px solid var(--ph-new-border-color);
      }
      #cancel-add-task-btn:hover,
      #info-modal-close-btn:hover {
        background-color: #dae0d9;
      }
      #add-current-task-modal-btn {
        background-color: var(--ph-new-light-green);
        color: var(--ph-new-dark-green);
      }
      #add-current-task-modal-btn:hover {
        background-color: #7a9877;
        color: var(--ph-new-white);
      }
      #analyze-tasks-modal-btn {
        background-color: var(--ph-new-dark-green);
        color: var(--ph-new-white);
      }
      #analyze-tasks-modal-btn:hover {
        background-color: var(--ph-new-medium-green);
      }

      #info-modal .modal-content {
        max-width: 600px;
        text-align: center;
        position: relative;
        max-height: 90vh;
        overflow-y: auto;
        padding: 30px;
      }

      /* Info Modal Header */
      #info-modal .modal-content h2 {
        margin: 0 0 20px 0;
        padding-right: 40px; /* Space for close button */
        font-size: 1.5em;
        color: var(--ph-new-text-dark);
      }

      /* Info Modal Close Button */
      #info-modal .modal-close-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 32px;
        height: 32px;
        border: none;
        background: rgba(0, 0, 0, 0.05);
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        color: var(--ph-new-text-medium);
        font-size: 14px;
        z-index: 10;
      }
      #info-modal .modal-close-btn:hover {
        background: rgba(0, 0, 0, 0.1);
        color: var(--ph-new-text-dark);
        transform: scale(1.1);
      }

      #info-modal-image {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        object-fit: cover;
        margin: 0 auto 20px auto;
        border: 4px solid var(--ph-new-light-green);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      }
      #info-modal-description {
        font-size: 0.95em;
        color: var(--ph-new-text-medium);
        line-height: 1.7;
        margin-bottom: 25px;
        text-align: left;
      }
      #info-modal-description strong {
        color: var(--ph-new-dark-green);
        font-weight: 600;
      }
      #info-modal-description ul {
        padding-left: 20px;
        margin: 15px 0;
      }
      #info-modal-description li {
        margin-bottom: 12px;
        line-height: 1.6;
      }
      #info-modal-footer {
        font-size: 0.85em;
        color: var(--ph-new-text-medium);
        margin-top: 30px;
        padding-top: 15px;
        border-top: 1px solid var(--ph-new-border-color);
      }

      #dashboard-summary {
        display: grid;
        grid-template-columns: repeat(
          auto-fit,
          minmax(220px, 1fr)
        ); /* Slightly smaller min for more flexibility */
        gap: 20px;
        margin-bottom: 35px;
      }
      .dashboard-item {
        padding: 20px;
        border-radius: 12px;
        background-color: var(--ph-new-white);
        border: 1px solid var(--ph-new-border-color);
        box-shadow: var(--ph-new-shadow);
        transition: transform 0.25s ease, box-shadow 0.25s ease;
        position: relative;
        overflow: hidden; /* Helps contain tilted content */
      }
      .dashboard-item:hover {
        transform: translateY(-3px);
        box-shadow: var(--ph-new-shadow-hover);
      }
      .dashboard-item-header h3 {
        font-size: 0.85em;
        color: var(--ph-new-text-medium);
        font-weight: 500;
        margin-bottom: 6px;
      }
      .dashboard-item-value {
        font-size: 1.9em;
        font-weight: 600;
        color: var(--ph-new-text-dark);
        font-family: var(--font-primary);
        word-break: break-all; /* For very large numbers if they ever occur */
      }
      .dashboard-item p {
        /* Added for word break in any paragraph */
        word-break: break-word;
      }

      #task-columns-container {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 20px;
      }
      .task-column {
        background-color: var(--ph-new-soft-green-bg);
        border-radius: 16px;
        padding: 20px;
        border: 1px solid #e0e8de;
        display: flex;
        flex-direction: column;
        min-height: 360px;
        box-shadow: none;
        transition: transform 0.25s ease, box-shadow 0.25s ease;
      }
      .task-column:hover {
        transform: translateY(-3px);
        box-shadow: var(--ph-new-shadow-hover);
      }
      .task-column h3 {
        font-family: var(--font-primary);
        font-size: 1.15em;
        font-weight: 600;
        margin-bottom: 18px;
        padding-bottom: 12px;
        border-bottom: 1px solid var(--ph-new-border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: var(--ph-new-text-dark);
        flex-wrap: wrap;
        gap: 5px;
      }
      .task-column h3 i {
        margin-right: 9px;
        font-size: 1.05em;
      }
      .priority-range {
        font-size: 0.7em;
        font-weight: 500;
        color: var(--ph-new-text-medium);
        background-color: var(--ph-new-soft-green-bg);
        padding: 2px 6px;
        border-radius: 4px;
        border: 1px solid var(--ph-new-border-color);
      }

      /* Overall Progress Bar */
      .overall-progress-container {
        background-color: var(--ph-new-white);
        border: 1px solid var(--ph-new-border-color);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 25px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      }

      /* Carry Forward Section */
      .carry-forward-container {
        background-color: var(--ph-new-white);
        border: 1px solid var(--ph-new-border-color);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 25px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      }
      .carry-forward-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }
      .carry-forward-header h4 {
        font-family: var(--font-primary);
        font-size: 1.1em;
        font-weight: 600;
        color: var(--ph-new-text-dark);
        margin: 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .carry-forward-header h4 i {
        color: var(--ph-new-medium-green);
      }
      .carry-forward-buttons {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .carry-forward-btn,
      .fetch-again-btn {
        background-color: var(--ph-new-medium-green);
        color: var(--ph-new-white);
        border: none;
        padding: 10px 16px;
        border-radius: 8px;
        font-size: 0.9em;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .fetch-again-btn {
        background-color: var(--ph-new-light-green);
        padding: 8px 14px;
        font-size: 0.85em;
      }
      .carry-forward-btn:hover,
      .fetch-again-btn:hover {
        background-color: var(--ph-new-dark-green);
        transform: translateY(-1px);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
      }
      .fetch-again-btn:hover {
        background-color: var(--ph-new-medium-green);
      }
      .carry-forward-info {
        font-size: 0.9em;
        color: var(--ph-new-text-medium);
        font-weight: 500;
      }
      .carry-forward-loading {
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
        padding: 10px 0;
      }
      .loading-bar {
        width: 100%;
        height: 6px;
        background: var(--ph-new-border-color);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
      }
      .loading-progress {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--ph-new-medium-green) 0%,
          var(--ph-new-light-green) 50%,
          var(--ph-new-medium-green) 100%
        );
        border-radius: 3px;
        width: 0%;
        transition: width 0.3s ease;
        animation: loadingShimmer 1.5s infinite;
      }
      @keyframes loadingShimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }
      .loading-text {
        font-size: 0.85em;
        color: var(--ph-new-text-medium);
        text-align: center;
        font-weight: 500;
      }
      .carry-forward-result {
        text-align: center;
      }
      .overall-progress-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }
      .overall-progress-header h4 {
        font-family: var(--font-primary);
        font-size: 1.1em;
        font-weight: 600;
        color: var(--ph-new-text-dark);
        margin: 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .overall-progress-header h4 i {
        color: var(--ph-new-medium-green);
      }
      .overall-progress-text {
        font-size: 0.9em;
        color: var(--ph-new-text-medium);
        font-weight: 500;
      }
      .overall-progress-bar {
        height: 12px;
        background-color: var(--ph-new-border-color);
        border-radius: 6px;
        overflow: hidden;
        position: relative;
      }
      .overall-progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--ph-new-medium-green),
          var(--ph-new-light-green)
        );
        border-radius: 6px;
        width: 0%;
        transition: width 0.8s ease-in-out;
        position: relative;
      }
      .overall-progress-fill::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.4),
          transparent
        );
        animation: shimmer 2.5s infinite;
      }
      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      /* Progress Milestone Styles */
      .overall-progress-container.milestone-25 {
        border-color: #fbbf24;
        box-shadow: 0 2px 8px rgba(251, 191, 36, 0.2);
      }
      .overall-progress-container.milestone-50 {
        border-color: #f59e0b;
        box-shadow: 0 2px 8px rgba(245, 158, 11, 0.2);
      }
      .overall-progress-container.milestone-75 {
        border-color: #10b981;
        box-shadow: 0 2px 8px rgba(16, 185, 129, 0.2);
      }
      .overall-progress-container.milestone-100 {
        border-color: var(--ph-new-medium-green);
        box-shadow: 0 2px 8px rgba(var(--ph-new-medium-green), 0.3);
        background: linear-gradient(
          135deg,
          var(--ph-new-white),
          var(--ph-new-soft-green-bg)
        );
      }

      /* Focus Mode Styles */
      .focus-mode-content {
        text-align: center;
        padding: 20px;
      }
      .focus-timer-container {
        margin-bottom: 30px;
      }
      .focus-timer-display {
        font-size: 4em;
        font-weight: 700;
        color: var(--ph-new-medium-green);
        margin-bottom: 20px;
        font-family: "Courier New", monospace;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .focus-timer-controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
      }
      .focus-control-btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        min-height: 44px;
      }
      .focus-control-btn.primary {
        background: var(--ph-new-medium-green);
        color: white;
      }
      .focus-control-btn.secondary {
        background: #f59e0b;
        color: white;
      }
      .focus-control-btn.tertiary {
        background: var(--ph-new-border-color);
        color: var(--ph-new-text-dark);
      }
      .focus-control-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      .focus-mode-description {
        text-align: left;
        margin-top: 30px;
      }
      .focus-mode-description ul {
        list-style: none;
        padding: 0;
      }
      .focus-mode-description li {
        padding: 8px 0;
        font-size: 0.95em;
      }

      /* Modern Close Button Styles */
      .modal-close-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 36px;
        height: 36px;
        border: none;
        background: rgba(0, 0, 0, 0.05);
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        color: var(--ph-new-text-medium);
        font-size: 14px;
        z-index: 10;
      }
      .modal-close-btn:hover {
        background: rgba(0, 0, 0, 0.1);
        color: var(--ph-new-text-dark);
        transform: scale(1.1);
      }
      .modal-close-btn:active {
        transform: scale(0.95);
      }

      /* Focus Mode Active State */
      body.focus-mode-active {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        color: #e0e0e0;
      }
      body.focus-mode-active
        .task-column:not(#very-important-column):not(#high-priority-column) {
        display: none;
      }
      body.focus-mode-active .overall-progress-container {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.2);
      }
      body.focus-mode-active .header {
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
      }

      /* Mood Selection Styles */
      .mood-modal-content {
        max-width: 500px;
      }
      .mood-options {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
        margin-bottom: 25px;
      }
      .mood-option {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px 15px;
        border: 2px solid var(--ph-new-border-color);
        border-radius: 12px;
        background: var(--ph-new-white);
        cursor: pointer;
        transition: all 0.3s ease;
        min-height: 44px;
      }
      .mood-option:hover {
        border-color: var(--ph-new-medium-green);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }
      .mood-option.selected {
        border-color: var(--ph-new-medium-green);
        background: var(--ph-new-soft-green-bg);
      }
      .mood-emoji {
        font-size: 2em;
        margin-bottom: 8px;
      }
      .mood-label {
        font-size: 0.9em;
        font-weight: 500;
        color: var(--ph-new-text-dark);
      }
      .mood-actions {
        text-align: center;
        margin-top: 20px;
      }

      /* Modern Skip Button Styles */
      #skip-mood-btn {
        background: transparent;
        border: 2px solid var(--ph-new-border-color);
        color: var(--ph-new-text-medium);
        padding: 12px 24px;
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        min-height: 44px;
        font-size: 0.9em;
      }
      #skip-mood-btn:hover {
        border-color: var(--ph-new-medium-green);
        color: var(--ph-new-medium-green);
        background: rgba(var(--ph-new-medium-green), 0.05);
        transform: translateY(-1px);
      }
      #skip-mood-btn:active {
        transform: translateY(0);
      }

      /* Task mood indicators */
      .task-mood-indicator {
        font-size: 1.2em;
        margin-left: 8px;
        opacity: 0.8;
      }
      #very-important-column h3 i {
        color: var(--accent-blue);
      }
      #high-priority-column h3 i {
        color: var(--accent-red);
      }
      #good-good-priority-column h3 i {
        color: var(--accent-yellow);
      }
      #low-priority-column h3 i {
        color: var(--accent-purple);
      }

      .task-column ul {
        list-style: none;
        padding: 0;
        flex-grow: 1;
      }
      .task-column li {
        padding: 15px;
        margin-bottom: 14px;
        border-radius: 10px;
        background-color: var(--ph-new-white);
        border: 1px solid #e8ede7;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.04);
        transition: transform 0.25s ease-out, box-shadow 0.25s ease-out;
        cursor: pointer;
        position: relative;
        overflow: hidden; /* To contain text */
      }
      .task-column li:hover {
        box-shadow: 0 5px 12px rgba(0, 0, 0, 0.07);
        transform: translateY(-3px);
      }
      .task-column li.completed {
        background-color: #f0f7ef;
        border-left: 4px solid var(--ph-new-medium-green);
      }
      .task-column li.completed .task-text,
      .task-column li.completed .task-reason {
        text-decoration: line-through;
        color: var(--ph-new-text-medium);
        opacity: 0.6;
      }
      .task-main-content {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .task-text-and-emoji {
        display: flex;
        align-items: center;
        flex-grow: 1;
        min-width: 0; /* Allow shrinking */
      }
      .task-text {
        font-weight: 500;
        font-size: 0.9em;
        color: var(--ph-new-text-dark);
        margin-right: 7px;
        word-break: break-word; /* Ensure task text wraps */
      }
      .task-emoji {
        font-size: 1.05em;
      }
      .task-complete-icon {
        cursor: pointer;
        font-size: 1.25em;
        color: #b0bfc0;
        margin-left: 10px;
        transition: color 0.3s ease, transform 0.2s ease;
        flex-shrink: 0;
      }
      .task-complete-icon:hover {
        transform: scale(1.05);
      }
      .task-column li.completed .task-complete-icon {
        color: var(--ph-new-medium-green);
      }
      .task-column li:not(.completed) .task-complete-icon:hover {
        color: var(--ph-new-medium-green);
      }

      /* Carried Forward Tasks */
      .task-column li.carried-forward {
        background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        border-left: 4px solid #f39c12;
        position: relative;
      }
      /* Removed corner icon - now only shows in message text */
      .carry-forward-count {
        font-size: 0.7em;
        color: #8b4513;
        font-weight: 600;
        background: rgba(243, 156, 18, 0.2);
        padding: 2px 6px;
        border-radius: 4px;
        margin-top: 4px;
        display: inline-block;
      }

      .task-completion-note {
        font-size: 0.7em;
        color: #27ae60;
        font-weight: 600;
        background: rgba(39, 174, 96, 0.1);
        padding: 2px 6px;
        border-radius: 4px;
        margin-top: 4px;
        display: inline-block;
        border-left: 2px solid #27ae60;
      }

      /* Task Actions */
      .task-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .task-abort-icon {
        cursor: pointer;
        font-size: 1.1em;
        color: #dc3545;
        transition: color 0.3s ease, transform 0.2s ease;
        flex-shrink: 0;
      }
      .task-abort-icon:hover {
        color: #c82333;
        transform: scale(1.1);
      }
      .task-reason {
        font-size: 0.78em;
        color: var(--ph-new-text-medium);
        margin-top: 5px;
        padding-left: 2px;
        font-style: italic;
        opacity: 0.9;
        word-break: break-word; /* Ensure reason wraps */
      }
      .task-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 9px;
        padding-top: 7px;
        border-top: 1px solid #eff2ee;
      }
      .task-creation-date {
        font-size: 0.68em;
        color: #9aaab0;
      }
      .task-assignee-placeholder {
        width: 20px;
        height: 20px;
        background-color: var(--ph-new-light-green);
        border-radius: 50%;
        font-size: 0.68em;
        color: var(--ph-new-dark-green);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
      }

      /* Enhanced Priority Indicators */
      .task-priority-indicators {
        display: flex;
        gap: 4px;
        align-items: center;
      }
      .priority-score,
      .confidence-score {
        font-size: 0.6em;
        padding: 2px 4px;
        border-radius: 3px;
        font-weight: 600;
        cursor: help;
        transition: all 0.2s ease;
      }
      .priority-score {
        background-color: var(--ph-new-medium-green);
        color: var(--ph-new-white);
      }
      .confidence-score {
        background-color: var(--ph-new-light-green);
        color: var(--ph-new-dark-green);
      }
      .priority-score:hover,
      .confidence-score:hover {
        transform: scale(1.05);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      /* Smart Suggestions Modal Styles */
      .suggestions-intro {
        color: var(--ph-new-text-medium);
        font-size: 0.9em;
        margin-bottom: 20px;
        text-align: center;
      }
      .suggestions-container {
        max-height: 400px;
        overflow-y: auto;
        margin-bottom: 20px;
      }
      .suggestion-item {
        background-color: var(--ph-new-soft-green-bg);
        border: 1px solid var(--ph-new-border-color);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 12px;
        transition: all 0.2s ease;
        cursor: pointer;
      }
      .suggestion-item:hover {
        background-color: var(--ph-new-light-green);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .suggestion-item.selected {
        background-color: var(--ph-new-medium-green);
        color: var(--ph-new-white);
        border-color: var(--ph-new-dark-green);
      }
      .suggestion-checkbox {
        width: 18px;
        height: 18px;
        border: 2px solid var(--ph-new-medium-green);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      .suggestion-checkbox.checked {
        background-color: var(--ph-new-medium-green);
        color: var(--ph-new-white);
      }
      .suggestion-text {
        flex: 1;
        font-weight: 500;
      }
      .suggestion-reason {
        font-size: 0.8em;
        color: var(--ph-new-text-medium);
        margin-top: 4px;
      }
      .suggestion-item.selected .suggestion-reason {
        color: rgba(255, 255, 255, 0.8);
      }
      .suggestions-actions {
        display: flex;
        gap: 10px;
        justify-content: center;
        padding-top: 15px;
        border-top: 1px solid var(--ph-new-border-color);
      }
      .modal-action-btn {
        padding: 10px 20px;
        border-radius: 6px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.9em;
      }
      .modal-action-btn.primary {
        background-color: var(--ph-new-dark-green);
        color: var(--ph-new-white);
        border: none;
      }
      .modal-action-btn.secondary {
        background-color: var(--ph-new-white);
        color: var(--ph-new-dark-green);
        border: 2px solid var(--ph-new-medium-green);
      }
      .modal-action-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
      }
      .modal-action-btn.primary:hover {
        background-color: var(--ph-new-medium-green);
      }
      .modal-action-btn.secondary:hover {
        background-color: var(--ph-new-light-green);
      }
      .motivational-quote {
        font-family: var(--font-primary);
        font-size: 0.9em;
        font-weight: 500;
        color: var(--ph-new-text-medium);
        margin-top: auto;
        padding-top: 14px;
        border-top: 1px dashed var(--ph-new-border-color);
        text-align: center;
        opacity: 0.9;
      }

      #task-behavioural-analysis {
        background-color: var(--ph-new-white);
        padding: 28px;
        border-radius: 16px;
        margin-bottom: 30px;
        border: 1px solid var(--ph-new-border-color);
        box-shadow: var(--ph-new-shadow);
      }
      .behavioural-header {
        display: flex;
        flex-wrap: wrap; /* Allow wrapping */
        justify-content: space-between;
        align-items: center;
        margin-bottom: 22px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--ph-new-border-color);
        gap: 10px; /* Gap for wrapped items */
      }
      .behavioural-header h2 {
        font-family: var(--font-primary);
        font-size: 1.6em;
        font-weight: 600;
        color: var(--ph-new-text-dark);
        margin-bottom: 0;
        flex-basis: 100%; /* Take full width on small screens initially */
      }
      @media (min-width: 500px) {
        /* Adjust breakpoint as needed */
        .behavioural-header h2 {
          flex-basis: auto; /* Allow shrinking next to other items */
        }
      }
      .behavioural-header p {
        font-size: 0.85em;
        color: var(--ph-new-text-medium);
      }
      #back-to-tasks-from-behaviour-btn {
        background-color: var(--ph-new-medium-green);
        color: var(--ph-new-white);
        padding: 9px 18px;
        font-size: 0.85em;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-weight: 500;
        margin-left: auto; /* Push to right if space allows */
      }
      #back-to-tasks-from-behaviour-btn:hover {
        background-color: var(--ph-new-dark-green);
      }
      #back-to-tasks-from-behaviour-btn i {
        margin-right: 5px;
      }

      .behavioural-grid {
        display: grid;
        grid-template-columns: repeat(
          auto-fit,
          minmax(280px, 1fr)
        ); /* Reduced minmax for more flexibility */
        gap: 20px;
      }
      .behaviour-card {
        background-color: var(--ph-new-soft-green-bg);
        padding: 20px;
        border-radius: 12px;
        border: 1px solid #e0e8de;
        transition: transform 0.25s ease, box-shadow 0.25s ease;
        overflow: hidden; /* Prevent content from breaking out */
      }
      .behaviour-card:hover {
        transform: translateY(-3px);
        box-shadow: var(--ph-new-shadow-hover);
      }
      .behaviour-card.behaviour-card-chart {
        grid-column: 1 / -1; /* Span full width */
        margin-top: 10px; /* Reduced margin */
      }
      .behaviour-card h4 {
        font-family: var(--font-primary);
        font-size: 1.05em;
        color: var(--ph-new-text-dark);
        margin-bottom: 10px;
        font-weight: 500;
        display: flex;
        align-items: center;
      }
      .behaviour-card h4 i {
        margin-right: 7px;
        color: var(--ph-new-medium-green);
        font-size: 1.15em;
      }
      .behaviour-card p {
        color: var(--ph-new-text-medium);
        font-size: 0.88em;
        margin-bottom: 7px;
        word-break: break-word; /* Ensure text wraps */
      }
      .behaviour-card p strong {
        color: var(--ph-new-text-dark);
        font-weight: 600;
      }
      .behaviour-card .small-text {
        font-size: 0.78em;
        color: var(--ph-new-text-medium);
        opacity: 0.8;
      }
      .chart-container-behaviour {
        min-height: 280px; /* Increased to allow for rotated labels */
        height: auto; /* Let it grow if needed */
        max-height: 350px; /* Cap height */
        position: relative;
        width: 100%;
        margin-top: 15px;
        overflow-x: auto; /* Allow horizontal scroll for chart if absolutely needed */
      }

      /* Header User Info Section */
      .header-user-info {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      /* Streak Display */
      .streak-display {
        display: flex;
        align-items: center;
        gap: 5px;
        background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
        color: white;
        padding: 8px 12px;
        border-radius: 20px;
        font-weight: 600;
        font-size: 0.9em;
        box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
        transition: all 0.3s ease;
      }

      .streak-display:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
      }

      .streak-icon {
        font-size: 1.1em;
        animation: flicker 2s infinite alternate;
      }

      @keyframes flicker {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0.7;
        }
      }

      .streak-count {
        font-weight: 700;
        min-width: 20px;
        text-align: center;
      }

      /* Username Section in Header */
      .username-section {
        position: relative;
        display: flex;
        align-items: center;
      }

      .username-display {
        font-size: 0.9em;
        font-weight: 600;
        color: var(--ph-new-dark-green);
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        white-space: nowrap;
        max-width: 120px;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: pointer;
        padding: 8px 12px;
        border-radius: 12px;
        transition: all 0.3s ease;
        background-color: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
      }

      .username-display:hover {
        background-color: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
      }

      .username-dropdown {
        position: absolute;
        top: 100%;
        right: 0;
        background-color: var(--ph-new-white);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        border: 1px solid var(--ph-new-border-color);
        min-width: 120px;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-10px);
        transition: all 0.3s ease;
      }

      .username-dropdown.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
      }

      .dropdown-item {
        display: flex;
        align-items: center;
        gap: 8px;
        width: 100%;
        padding: 12px 16px;
        background: none;
        border: none;
        color: var(--ph-new-text-dark);
        font-size: 0.9em;
        cursor: pointer;
        transition: background-color 0.2s ease;
        border-radius: 8px;
      }

      .dropdown-item:hover {
        background-color: var(--ph-new-soft-green-bg);
        color: var(--ph-new-dark-green);
      }

      .dropdown-item i {
        font-size: 0.9em;
        color: var(--ph-new-medium-green);
      }

      /* Custom Username Prompt Styles */
      #custom-username-prompt {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 99999;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .custom-prompt-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
      }

      .custom-prompt-container {
        position: relative;
        background: linear-gradient(135deg, #ffffff 0%, #f8fffe 100%);
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 480px;
        width: 90%;
        overflow: hidden;
        animation: promptSlideIn 0.4s ease-out;
      }

      @keyframes promptSlideIn {
        from {
          opacity: 0;
          transform: translateY(-50px) scale(0.9);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .custom-prompt-header {
        background: linear-gradient(
          135deg,
          var(--ph-new-dark-green) 0%,
          var(--ph-new-medium-green) 100%
        );
        color: white;
        padding: 25px 30px;
        text-align: center;
      }

      .custom-prompt-header h3 {
        margin: 0;
        font-size: 1.5em;
        font-weight: 700;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .custom-prompt-body {
        padding: 30px;
      }

      .prompt-message {
        background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        border: 2px solid #f39c12;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 25px;
        color: #8b4513;
        font-size: 0.95em;
        line-height: 1.5;
        text-align: center;
        font-weight: 500;
        box-shadow: 0 4px 12px rgba(243, 156, 18, 0.2);
      }

      .prompt-input-group {
        margin-bottom: 0;
      }

      #custom-username-input {
        width: 100%;
        padding: 16px 20px;
        border: 3px solid var(--ph-new-border-color);
        border-radius: 12px;
        font-size: 1.1em;
        font-weight: 500;
        transition: all 0.3s ease;
        background: #ffffff;
        color: var(--ph-new-text-dark);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      #custom-username-input:focus {
        outline: none;
        border-color: var(--ph-new-dark-green);
        box-shadow: 0 0 0 4px rgba(139, 168, 137, 0.2),
          0 4px 12px rgba(0, 0, 0, 0.15);
        transform: translateY(-2px);
      }

      .prompt-help {
        margin-top: 10px;
        font-size: 0.85em;
        color: var(--ph-new-text-medium);
        text-align: center;
        font-style: italic;
      }

      .custom-prompt-footer {
        padding: 0 30px 30px 30px;
        text-align: center;
      }

      .prompt-btn {
        padding: 14px 40px;
        border: none;
        border-radius: 12px;
        font-size: 1.1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .prompt-btn-primary {
        background: linear-gradient(
          135deg,
          var(--ph-new-dark-green) 0%,
          var(--ph-new-medium-green) 100%
        );
        color: white;
        box-shadow: 0 6px 20px rgba(139, 168, 137, 0.4);
      }

      .prompt-btn-primary:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(139, 168, 137, 0.6);
      }

      .prompt-btn-primary:active {
        transform: translateY(-1px);
      }

      .prompt-btn:disabled {
        background: #cccccc;
        color: #666666;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      /* Profile Modal Styles */
      .profile-modal-content {
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        border-radius: 20px;
        background: linear-gradient(
          135deg,
          var(--ph-new-white) 0%,
          var(--ph-new-soft-green-bg) 100%
        );
      }
      .profile-modal-body {
        padding: 0 24px 24px 24px;
      }
      .current-profile-section {
        display: flex;
        gap: 20px;
        margin-bottom: 30px;
        padding: 20px;
        background-color: var(--ph-new-white);
        border-radius: 16px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      }
      .current-avatar-container {
        flex-shrink: 0;
      }
      .current-profile-img {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        object-fit: cover;
        border: 3px solid var(--ph-new-light-green);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }
      .profile-details {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      .username-section {
        position: relative;
      }
      .username-display {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .username-display span {
        font-size: 1.2em;
        font-weight: 600;
        color: var(--ph-new-text-dark);
      }
      .edit-username-btn {
        background: none;
        border: none;
        color: var(--ph-new-medium-green);
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        transition: all 0.2s ease;
      }
      .edit-username-btn:hover {
        background-color: var(--ph-new-soft-green-bg);
        color: var(--ph-new-dark-green);
      }
      .username-edit {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 8px;
      }
      .username-edit input {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid var(--ph-new-border-color);
        border-radius: 8px;
        font-size: 1em;
        background-color: var(--ph-new-white);
      }
      .username-edit input:focus {
        outline: none;
        border-color: var(--ph-new-medium-green);
        box-shadow: 0 0 0 2px rgba(73, 101, 78, 0.2);
      }
      .username-actions {
        display: flex;
        gap: 4px;
      }
      .save-username-btn,
      .cancel-username-btn {
        width: 32px;
        height: 32px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }
      .save-username-btn {
        background-color: var(--ph-new-medium-green);
        color: white;
      }
      .save-username-btn:hover {
        background-color: var(--ph-new-dark-green);
      }
      .cancel-username-btn {
        background-color: #dc3545;
        color: white;
      }
      .cancel-username-btn:hover {
        background-color: #c82333;
      }
      .streak-display {
        display: flex;
        flex-direction: row !important;
        align-items: center !important;
        gap: 5px !important;
      }
      .streak-info {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .streak-icon {
        color: #ff6b35;
        font-size: 1.2em;
      }
      .streak-count {
        font-size: 1.5em;
        font-weight: 700;
        color: var(--ph-new-dark-green);
      }
      .streak-label {
        font-size: 0.9em;
        color: var(--ph-new-text-medium);
        font-weight: 500;
      }
      .streak-description {
        font-size: 0.8em;
        color: var(--ph-new-text-medium);
        font-style: italic;
      }

      /* Profile Pictures Section */
      .profile-pictures-section {
        margin-bottom: 30px;
      }
      .profile-pictures-section h4 {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 16px;
        color: var(--ph-new-text-dark);
        font-size: 1.1em;
        font-weight: 600;
      }
      .profile-pictures-section h4 i {
        color: var(--ph-new-medium-green);
      }
      .profile-pictures-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
        gap: 12px;
        max-height: 200px;
        overflow-y: auto;
        padding: 16px;
        background-color: var(--ph-new-white);
        border-radius: 12px;
        border: 1px solid var(--ph-new-border-color);
      }
      .profile-picture-option {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        overflow: hidden;
        cursor: pointer;
        border: 2px solid transparent;
        transition: all 0.3s ease;
        position: relative;
      }
      .profile-picture-option:hover {
        border-color: var(--ph-new-medium-green);
        transform: scale(1.05);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      .profile-picture-option.selected {
        border-color: var(--ph-new-dark-green);
        box-shadow: 0 0 0 3px rgba(73, 101, 78, 0.3);
      }
      .profile-picture-option img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform 0.3s ease;
      }
      .profile-picture-option:hover img {
        transform: scale(1.1);
      }
      .profile-picture-option.selected::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: var(--ph-new-dark-green);
        color: white;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
      }

      /* Profile Actions */
      .profile-actions {
        display: flex;
        justify-content: center;
        padding-top: 20px;
        border-top: 1px solid var(--ph-new-border-color);
      }
      .logout-btn-modal {
        background-color: #dc3545;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 1em;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.3s ease;
      }
      .logout-btn-modal:hover {
        background-color: #c82333;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
      }

      /* Mobile Responsiveness for Header */
      @media (max-width: 768px) {
        .username-section {
          position: relative;
        }

        .username-display {
          font-size: 0.8em;
          max-width: 80px;
          padding: 6px 10px;
        }

        .username-dropdown {
          right: 0;
          min-width: 100px;
        }

        .dropdown-item {
          padding: 10px 12px;
          font-size: 0.85em;
        }
      }

      /* Authentication Loading Screen */
      .auth-loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--ph-new-bg-page);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10001;
        font-family: var(--font-primary);
      }
      .auth-loading-content {
        text-align: center;
        color: var(--ph-new-text-dark);
      }
      .auth-loading-content .logo-placeholder {
        width: 64px;
        height: 64px;
        border-radius: 16px;
        margin: 0 auto 20px auto;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .auth-loading-content .logo-placeholder img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 16px;
      }
      .auth-loading-content h2 {
        font-size: 1.8em;
        font-weight: 600;
        margin-bottom: 20px;
        color: var(--ph-new-text-dark);
      }
      .auth-loading-spinner {
        margin: 20px 0;
      }
      .auth-loading-content p {
        color: var(--ph-new-text-medium);
        font-size: 0.9em;
      }

      #loading-spinner {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(243, 245, 240, 0.92);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
      }
      .circular-loader {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: 5px solid var(--ph-new-soft-green-bg);
        border-top-color: var(--ph-new-dark-green);
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      @media (max-width: 1200px) {
        .app-content-area {
          padding: 25px 25px; /* Reduced padding */
        }
        /* Keep .header-center-section visible but allow flex to manage space */
        .header-title-section h1#animated-logo-title {
          font-size: 1.3em;
        }
        .header-nav a,
        .behaviour-analysis-btn-nav {
          font-size: 0.8em;
          padding: 5px 8px;
        }
      }

      @media (max-width: 992px) {
        .main-app-layout {
          padding: 0; /* Removed body padding effect */
        }
        .content-wrapper-card {
          border-radius: 20px;
        }
        .app-header-bar {
          flex-wrap: wrap;
          justify-content: space-between; /* Ensure items spread out */
          padding: 15px 20px;
        }
        .header-title-section {
          width: auto;
          margin-bottom: 0; /* Remove default margin if wrapped */
        }
        .header-center-section {
          order: 3;
          width: 100%;
          justify-content: center;
          padding-top: 10px;
          margin-top: 10px; /* Add margin when it wraps */
          border-top: 1px solid var(--ph-new-border-color);
        }
        .header-nav {
          order: 2; /* Nav comes after title on same line if possible */
          padding-top: 0;
          margin-left: 0; /* Remove margin when wrapping occurs */
        }

        .hero-intro-section {
          padding: 20px 0;
          text-align: center;
        }
        .hero-description {
          margin-left: auto;
          margin-right: auto;
        }
        .hero-title {
          font-size: 1.8em;
        }

        #task-columns-container {
          grid-template-columns: 1fr 1fr;
        }
        .behavioural-grid {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 768px) {
        body {
          padding: 10px;
        } /* Reduce body padding */
        .main-app-layout {
          min-height: calc(100vh - 20px);
        }
        .app-header-bar {
          flex-direction: column;
          align-items: center; /* Center items when stacked */
          gap: 10px;
          padding: 15px;
        }
        .header-title-section {
          width: auto;
          justify-content: center;
        } /* Center title */
        .header-center-section {
          order: 2;
          padding-top: 5px;
          margin-top: 5px;
          width: auto;
          border-top: none;
        }
        .header-nav {
          order: 3;
          width: auto;
          justify-content: center;
          margin-left: 0;
          padding-top: 5px;
          border-top: 1px solid var(--ph-new-border-color);
        }

        .content-wrapper-card {
          border-radius: 16px;
        }
        .app-content-area {
          padding: 15px;
        } /* Further reduce padding */
        .header-title-section h1 {
          font-size: 1.25em;
        }

        .hero-title {
          font-size: 1.6em;
        }
        .hero-cta-button {
          padding: 10px 22px;
          font-size: 0.9em;
        }

        #task-columns-container,
        #dashboard-summary {
          grid-template-columns: 1fr;
        }
        .task-column h3 {
          font-size: 1.1em;
        }
        .modal-content {
          padding: 20px;
          max-width: calc(100% - 20px);
        } /* Reduce padding, ensure it fits */
        .task-column {
          padding: 15px;
        }
      }

      @media (max-width: 480px) {
        body {
          padding: 5px;
        }
        .main-app-layout {
          min-height: calc(100vh - 10px);
        }
        .app-content-area {
          padding: 10px;
        }
        .hero-title {
          font-size: 1.4em;
        }
        .hero-description {
          font-size: 0.9em;
        }
        .dashboard-item-value {
          font-size: 1.7em;
        }
        .task-column li {
          padding: 12px;
        }
        .modal-actions {
          flex-direction: column;
          gap: 10px;
        }
        .modal-actions .button-style {
          width: 100%;
        }
        #task-input-field-modal {
          font-size: 0.95em;
        }

        .date-controls {
          flex-wrap: wrap;
          justify-content: center;
          gap: 5px;
        }
        #current-date-display {
          min-width: 110px;
          font-size: 0.8em;
          padding: 6px 8px;
        }
        .header-nav {
          gap: 5px;
          flex-wrap: wrap;
          justify-content: center;
        }
        .header-nav a,
        .behaviour-analysis-btn-nav {
          font-size: 0.8em;
        }
        .behavioural-header h2 {
          font-size: 1.4em;
          text-align: center;
        }
        .behavioural-header p {
          text-align: center;
          width: 100%;
        }
        #back-to-tasks-from-behaviour-btn {
          width: 100%;
          margin-left: 0;
          margin-top: 10px;
        }
      }

      /* Additional Mobile Optimizations for New Features */
      @media (max-width: 768px) {
        /* Hero buttons mobile */
        .hero-buttons {
          flex-direction: column;
          gap: 12px;
        }
        .hero-cta-button,
        .hero-secondary-button {
          width: 100%;
          min-height: 44px;
        }

        /* Overall progress bar mobile */
        .overall-progress-container {
          padding: 15px;
          margin-bottom: 20px;
        }
        .overall-progress-header {
          flex-direction: column;
          gap: 10px;
          text-align: center;
        }
        .overall-progress-header h4 {
          font-size: 1em;
        }
        .overall-progress-text {
          font-size: 0.85em;
        }

        /* Analytics mobile */
        .analytics-header {
          flex-direction: column;
          text-align: center;
        }
        .analytics-header h2 {
          font-size: 1.8em;
        }
        .analytics-grid {
          grid-template-columns: 1fr 1fr;
          gap: 15px;
        }
        .analytics-card {
          padding: 20px 15px;
        }
        .metric-value {
          font-size: 2em;
        }
        .charts-container {
          grid-template-columns: 1fr;
          gap: 20px;
        }
        .chart-card {
          padding: 20px 15px;
        }
        .chart-card canvas {
          height: 250px;
        }

        /* Focus mode mobile */
        .focus-timer-display {
          font-size: 3em;
        }
        .focus-timer-controls {
          flex-direction: column;
          gap: 10px;
        }
        .focus-control-btn {
          width: 100%;
          justify-content: center;
        }

        /* Mood selection mobile */
        .mood-options {
          grid-template-columns: repeat(2, 1fr);
          gap: 12px;
        }
        .mood-option {
          padding: 15px 10px;
        }
        .mood-emoji {
          font-size: 1.5em;
        }
      }

      @media (max-width: 480px) {
        /* Single column layout for small screens */
        .analytics-grid {
          grid-template-columns: 1fr;
        }
        .analytics-nav {
          flex-direction: column;
          width: 100%;
        }
        .analytics-nav-btn {
          width: 100%;
          text-align: center;
        }

        /* Focus timer smaller */
        .focus-timer-display {
          font-size: 2.5em;
        }

        /* Mood options single column for very small screens */
        .mood-options {
          grid-template-columns: 1fr;
        }

        /* Header mobile */
        .header-nav {
          flex-direction: column;
          gap: 8px;
        }
        .behaviour-analysis-btn-nav {
          width: 100%;
          text-align: center;
          min-height: 44px;
        }

        /* Overall progress mobile */
        .overall-progress-header h4 {
          font-size: 0.9em;
        }
        .overall-progress-text {
          font-size: 0.8em;
        }
      }

      /* Touch-friendly improvements */
      @media (hover: none) and (pointer: coarse) {
        .button-style,
        .hero-cta-button,
        .hero-secondary-button,
        .focus-control-btn,
        .mood-option,
        .analytics-nav-btn {
          min-height: 44px;
          min-width: 44px;
        }

        .task-complete-icon {
          min-height: 44px;
          min-width: 44px;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .modal-close-btn {
          min-height: 44px;
          min-width: 44px;
        }

        .header-info-icon {
          min-height: 44px;
          min-width: 44px;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        /* Info Modal Mobile Optimizations */
        #info-modal .modal-content {
          max-width: 95vw;
          width: 95vw;
          max-height: 95vh;
          margin: 2.5vh auto;
          padding: 20px;
          border-radius: 12px;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }

        #info-modal .modal-content h2 {
          font-size: 1.3em;
          margin-bottom: 15px;
          padding-right: 35px;
          line-height: 1.3;
        }

        #info-modal .modal-close-btn {
          top: 12px;
          right: 12px;
          width: 28px;
          height: 28px;
          font-size: 12px;
          min-height: 44px; /* Touch target */
          min-width: 44px; /* Touch target */
          margin: -8px; /* Negative margin to maintain visual size */
        }

        #info-modal-image {
          width: 80px;
          height: 80px;
          margin-bottom: 15px;
          border-width: 3px;
        }

        #info-modal-description {
          font-size: 0.9em;
          line-height: 1.6;
          margin-bottom: 20px;
          text-align: left;
        }

        #info-modal-description ul {
          padding-left: 18px;
          margin: 12px 0;
        }

        #info-modal-description li {
          margin-bottom: 10px;
          line-height: 1.5;
          font-size: 0.9em;
        }

        #info-modal .modal-actions {
          margin-top: 20px;
          margin-bottom: 10px;
        }

        #info-modal-close-btn {
          width: 100%;
          min-height: 44px;
          font-size: 0.9em;
          padding: 12px 20px;
        }

        #info-modal-footer {
          font-size: 0.8em;
          margin-top: 20px;
          padding-top: 12px;
        }
      }

      /* Extra small mobile devices (320px and below) */
      @media (max-width: 320px) {
        #info-modal .modal-content {
          max-width: 98vw;
          width: 98vw;
          padding: 15px;
          margin: 1vh auto;
        }

        #info-modal .modal-content h2 {
          font-size: 1.2em;
        }

        #info-modal-description {
          font-size: 0.85em;
        }

        #info-modal-description li {
          font-size: 0.85em;
        }
      }
    </style>
  </head>
  <body>
    <div id="particles-js"></div>
    <div class="main-app-layout">
      <div class="content-wrapper-card">
        <header class="app-header-bar">
          <div class="header-title-section">
            <div class="logo-placeholder">
              <img src="https://shorturl.at/cQmMr" alt="PriorityHelp AI Logo" />
            </div>
            <h1 id="animated-logo-title">PriorityHelp AI</h1>
          </div>
          <div class="header-center-section">
            <div class="date-controls">
              <i class="fas fa-chevron-left" id="prev-day-btn"></i>
              <span id="current-date-display">Select Date</span>
              <input type="date" id="current-date-input" class="hidden" />
              <i class="fas fa-calendar-alt" id="calendar-icon-btn"></i>
              <i class="fas fa-chevron-right" id="next-day-btn"></i>
            </div>
          </div>
          <nav class="header-nav">
            <button
              class="behaviour-analysis-btn-nav"
              id="toggle-behaviour-analysis-btn"
            >
              Behaviour Analysis
            </button>
            <div class="header-user-info">
              <div class="streak-display" id="streak-display">
                <span class="streak-icon"></span>
                <span class="streak-count" id="streak-count">0</span>
              </div>
              <div class="username-section" id="username-section">
                <span class="username-display" id="username-display"
                  >Loading...</span
                >
                <div class="username-dropdown" id="username-dropdown">
                  <button class="dropdown-item" id="logout-btn">
                    <i class="fas fa-sign-out-alt"></i>
                    Logout
                  </button>
                </div>
              </div>
            </div>
            <i
              class="fas fa-info-circle header-info-icon"
              id="header-info-icon-btn"
            ></i>
          </nav>
        </header>

        <main class="app-content-area">
          <section class="hero-intro-section" data-aos="fade-in">
            <p class="hero-subtitle">Advanced AI-Driven Prioritization</p>
            <h2 class="hero-title" id="hero-animated-title">
              Precision Task Management
            </h2>
            <p class="hero-description">
              Experience next-level productivity with our enhanced AI system
              that analyzes urgency, importance, and impact to deliver precise
              task prioritization. Get objective scoring, confidence ratings,
              and strategic insights for better decision-making.
            </p>
            <div class="hero-buttons">
              <button class="hero-cta-button" id="header-add-task-btn-main">
                <i class="fas fa-brain"></i> Analyze Tasks
              </button>
              <button class="hero-secondary-button" id="focus-mode-btn">
                <i class="fas fa-eye"></i> Focus Mode
              </button>
            </div>
          </section>

          <section
            id="dashboard-summary"
            data-aos="fade-up"
            data-aos-delay="50"
          >
            <div
              class="dashboard-item"
              data-tilt
              data-tilt-max="2"
              data-tilt-speed="250"
              data-tilt-perspective="700"
            >
              <div class="dashboard-item-header"><h3>Tasks Created</h3></div>
              <p class="dashboard-item-value" id="tasks-created-today">0</p>
            </div>
            <div
              class="dashboard-item"
              data-tilt
              data-tilt-max="2"
              data-tilt-speed="250"
              data-tilt-perspective="700"
            >
              <div class="dashboard-item-header"><h3>Completed</h3></div>
              <p class="dashboard-item-value" id="tasks-completed">0</p>
            </div>
            <div
              class="dashboard-item"
              data-tilt
              data-tilt-max="2"
              data-tilt-speed="250"
              data-tilt-perspective="700"
            >
              <div class="dashboard-item-header"><h3>Remaining</h3></div>
              <p class="dashboard-item-value" id="tasks-remaining">0</p>
            </div>
          </section>

          <section id="task-behavioural-analysis" class="hidden">
            <div class="behavioural-header">
              <h2 id="behavioural-title">Task Behavioural Analysis</h2>
              <p>
                Insights for
                <span id="behavioural-analysis-date-display">current day</span>
              </p>
              <button
                id="back-to-tasks-from-behaviour-btn"
                class="button-style"
              >
                <i class="fas fa-arrow-left"></i> Back to Tasks
              </button>
            </div>
            <div class="behavioural-grid">
              <div
                class="behaviour-card"
                data-aos="fade-up"
                data-aos-delay="50"
                data-tilt
              >
                <h4><i class="fas fa-check-double"></i> Completion Rate</h4>
                <p>
                  Overall task completion:
                  <strong id="behaviour-completion-rate">0%</strong>
                </p>
                <div
                  class="progress-bar-container"
                  style="
                    background-color: var(--ph-new-border-color);
                    border-radius: 5px;
                    height: 10px;
                    margin-top: 10px;
                    overflow: hidden;
                  "
                >
                  <div
                    id="behaviour-completion-progress-bar"
                    style="
                      width: 0%;
                      height: 100%;
                      background-color: var(--ph-new-medium-green);
                      transition: width 0.5s ease-in-out;
                      border-radius: 5px;
                    "
                  ></div>
                </div>
              </div>
              <div
                class="behaviour-card"
                data-aos="fade-up"
                data-aos-delay="100"
                data-tilt
              >
                <h4><i class="fas fa-chart-line"></i> Priority Distribution</h4>
                <p>
                  Average Priority Score:
                  <strong id="avg-priority-score-behaviour">-</strong>
                </p>
                <p>
                  AI Confidence Level:
                  <strong id="avg-confidence-behaviour">-</strong>
                </p>
                <p class="small-text">
                  Higher scores indicate better task clarity and prioritization
                  accuracy.
                </p>
              </div>
              <div
                class="behaviour-card"
                data-aos="fade-up"
                data-aos-delay="125"
                data-tilt
              >
                <h4><i class="fas fa-seedling"></i> Focus Area</h4>
                <p>
                  Most tasks created in:
                  <strong id="focus-category-behaviour">-</strong>
                </p>
                <p class="small-text">Aligns with your strategic goals?</p>
              </div>
              <div
                class="behaviour-card behaviour-card-chart"
                data-aos="fade-up"
                data-tilt
              >
                <h4><i class="fas fa-chart-pie"></i> Category Completion</h4>
                <p>
                  How you're tackling different priorities for the selected day.
                </p>
                <div class="chart-container-behaviour">
                  <canvas id="completionByCategoryChart"></canvas>
                </div>
              </div>

              <div
                class="behaviour-card behaviour-card-chart"
                data-aos="fade-up"
                data-aos-delay="400"
                data-tilt
              >
                <h4><i class="fas fa-heart"></i> Mood Analytics</h4>
                <p>Your emotional state when completing tasks today.</p>
                <div class="chart-container-behaviour">
                  <canvas id="moodAnalyticsChart"></canvas>
                </div>
              </div>
            </div>
          </section>

          <!-- Overall Progress Bar -->
          <section
            class="overall-progress-container"
            id="overall-progress-container"
          >
            <div class="overall-progress-header">
              <h4><i class="fas fa-chart-line"></i> Overall Progress</h4>
              <span class="overall-progress-text" id="overall-progress-text"
                >0/0 tasks completed (0%)</span
              >
            </div>
            <div class="overall-progress-bar">
              <div
                class="overall-progress-fill"
                id="overall-progress-fill"
              ></div>
            </div>
          </section>

          <!-- Carry Forward Section -->
          <section
            class="carry-forward-container"
            id="carry-forward-container"
            style="display: none"
          >
            <div class="carry-forward-header">
              <h4>
                <i class="fas fa-arrow-right"></i> Previous Incomplete Tasks
              </h4>
              <div class="carry-forward-buttons">
                <button class="carry-forward-btn" id="add-previous-tasks-btn">
                  <i class="fas fa-plus"></i> Add Previous Incomplete Tasks
                </button>
                <button class="fetch-again-btn" id="fetch-again-btn">
                  <i class="fas fa-sync-alt"></i> Fetch Again
                </button>
              </div>
            </div>
            <div class="carry-forward-info" id="carry-forward-info">
              <div
                class="carry-forward-loading"
                id="carry-forward-loading"
                style="display: none"
              >
                <div class="loading-bar">
                  <div
                    class="loading-progress"
                    id="carry-forward-progress"
                  ></div>
                </div>
                <span class="loading-text"
                  >Fetching previous incomplete tasks...</span
                >
              </div>
              <div class="carry-forward-result" id="carry-forward-result">
                <span id="previous-tasks-count">0</span> incomplete tasks from
                all previous dates
              </div>
            </div>
          </section>

          <section id="task-columns-container">
            <div id="very-important-column" class="task-column" data-tilt>
              <h3><i class="fas fa-star"></i> Very Important</h3>
              <ul></ul>
              <p class="motivational-quote" id="quote-very-important"></p>
            </div>
            <div id="high-priority-column" class="task-column" data-tilt>
              <h3><i class="fas fa-rocket"></i> High Priority</h3>
              <ul></ul>
              <p class="motivational-quote" id="quote-high-priority"></p>
            </div>
            <div id="good-good-priority-column" class="task-column" data-tilt>
              <h3><i class="fas fa-thumbs-up"></i> Good-Good Priority</h3>
              <ul></ul>
              <p class="motivational-quote" id="quote-good-good"></p>
            </div>
            <div id="low-priority-column" class="task-column" data-tilt>
              <h3><i class="fas fa-mug-hot"></i> Low Priority</h3>
              <ul></ul>
              <p class="motivational-quote" id="quote-low-priority"></p>
            </div>
          </section>
        </main>
      </div>
    </div>

    <!-- Task Input Modal -->
    <div id="task-input-modal" class="modal-overlay hidden">
      <div class="modal-content">
        <h2 id="modal-title">Add New Task</h2>
        <div id="greeting-message-modal"></div>
        <input
          type="text"
          id="task-input-field-modal"
          placeholder="E.g., Draft project proposal by EOD"
        />
        <div
          id="current-tasks-list-modal"
          style="max-height: 140px; overflow-y: auto; margin-bottom: 12px"
        ></div>
        <div class="modal-actions">
          <button type="button" id="cancel-add-task-btn" class="button-style">
            Cancel
          </button>
          <button
            type="button"
            id="add-current-task-modal-btn"
            class="button-style"
          >
            Add This Task
          </button>
          <button
            type="button"
            id="analyze-tasks-modal-btn"
            class="button-style"
          >
            Analyze & Save Tasks
          </button>
        </div>
      </div>
    </div>

    <!-- Focus Mode Modal -->
    <div id="focus-mode-modal" class="modal-overlay hidden">
      <div class="modal-content" id="focus-mode-modal-content">
        <div class="modal-header">
          <h3><i class="fas fa-eye"></i> Focus Mode</h3>
          <button id="focus-mode-close-btn" class="modal-close-btn">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="focus-mode-content">
            <div class="focus-timer-container">
              <div class="focus-timer-display" id="focus-timer-display">
                25:00
              </div>
              <div class="focus-timer-controls">
                <button id="focus-start-btn" class="focus-control-btn primary">
                  <i class="fas fa-play"></i> Start Focus
                </button>
                <button
                  id="focus-pause-btn"
                  class="focus-control-btn secondary"
                  style="display: none"
                >
                  <i class="fas fa-pause"></i> Pause
                </button>
                <button id="focus-reset-btn" class="focus-control-btn tertiary">
                  <i class="fas fa-redo"></i> Reset
                </button>
              </div>
            </div>
            <div class="focus-mode-description">
              <p>
                Focus Mode will hide all distractions and show only your most
                important tasks. Perfect for deep work sessions!
              </p>
              <ul>
                <li> Shows only Very Important and High Priority tasks</li>
                <li> 25-minute Pomodoro timer</li>
                <li> Distraction-free environment</li>
                <li> Progress tracking</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Mood Selection Modal -->
    <div id="mood-selection-modal" class="modal-overlay hidden">
      <div class="modal-content mood-modal-content">
        <div class="modal-header">
          <h3>
            <i class="fas fa-heart"></i> How do you feel about completing this
            task?
          </h3>
        </div>
        <div class="modal-body">
          <div class="mood-options">
            <button
              class="mood-option"
              data-mood="accomplished"
              data-emoji=""
            >
              <span class="mood-emoji"></span>
              <span class="mood-label">Accomplished</span>
            </button>
            <button class="mood-option" data-mood="happy" data-emoji="">
              <span class="mood-emoji"></span>
              <span class="mood-label">Happy</span>
            </button>
            <button class="mood-option" data-mood="relieved" data-emoji="">
              <span class="mood-emoji"></span>
              <span class="mood-label">Relieved</span>
            </button>
            <button class="mood-option" data-mood="neutral" data-emoji="">
              <span class="mood-emoji"></span>
              <span class="mood-label">Neutral</span>
            </button>
            <button class="mood-option" data-mood="stressed" data-emoji="">
              <span class="mood-emoji"></span>
              <span class="mood-label">Stressed</span>
            </button>
            <button class="mood-option" data-mood="frustrated" data-emoji="">
              <span class="mood-emoji"></span>
              <span class="mood-label">Frustrated</span>
            </button>
          </div>
          <div class="mood-actions">
            <button id="skip-mood-btn" class="button-style secondary">
              Skip
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Info Modal -->
    <div id="info-modal" class="modal-overlay hidden">
      <div class="modal-content">
        <button class="modal-close-btn" id="info-modal-close-x-btn">
          <i class="fas fa-times"></i>
        </button>
        <h2>About PriorityHelp AI</h2>
        <img
          src="https://shorturl.at/2buFh"
          alt="Developer Devan"
          id="info-modal-image"
        />
        <div id="info-modal-description">
          <p>
            <strong>PriorityHelp AI</strong> features an enhanced,
            precision-driven task prioritization system. Our advanced AI
            analyzes your tasks using a multi-factor framework:
          </p>
          <ul>
            <li>
              <strong>Objective Scoring:</strong> Each task receives a priority
              score (1-10) based on urgency, importance, and impact.
            </li>
            <li>
              <strong>Confidence Ratings:</strong> AI provides confidence levels
              (1-10) indicating certainty in classifications.
            </li>
            <li>
              <strong>Strategic Categories:</strong> Tasks are sorted into
              Critical & Urgent, Important & Time-Sensitive, Beneficial &
              Flexible, and Optional & Deferrable.
            </li>
            <li>
              <strong>Detailed Analysis:</strong> Comprehensive reasoning
              explains why each task belongs in its category.
            </li>
            <li>
              <strong>Enhanced Analytics:</strong> Track priority distribution,
              confidence levels, and focus areas.
            </li>
          </ul>
          <p>
            This refined system delivers more reliable, AI-driven prioritization
            to support better decision-making and workflow efficiency.
            Experience the difference precision makes!
          </p>
        </div>
        <div class="modal-actions" style="justify-content: center">
          <button type="button" id="info-modal-close-btn" class="button-style">
            Close
          </button>
        </div>
        <div id="info-modal-footer">Created by Devan </div>
      </div>
    </div>

    <!-- Authentication Loading Screen -->
    <div id="auth-loading" class="auth-loading-screen">
      <div class="auth-loading-content">
        <div class="logo-placeholder">
          <img src="https://shorturl.at/cQmMr" alt="PriorityHelp AI Logo" />
        </div>
        <h2>PriorityHelp AI</h2>
        <div class="auth-loading-spinner">
          <div class="circular-loader"></div>
        </div>
        <p>Checking authentication...</p>
      </div>
    </div>

    <div id="loading-spinner" class="hidden">
      <div class="circular-loader"></div>
    </div>

    <!-- Custom Username Setup Prompt -->
    <div id="custom-username-prompt" style="display: none">
      <div class="custom-prompt-overlay"></div>
      <div class="custom-prompt-container">
        <div class="custom-prompt-header">
          <h3> Set Your Username</h3>
        </div>
        <div class="custom-prompt-body">
          <p class="prompt-message">
            This will show only one time. After setting your username, you
            cannot change it later. Choose carefully.
          </p>
          <div class="prompt-input-group">
            <input
              type="text"
              id="custom-username-input"
              placeholder="Enter your username"
              maxlength="30"
            />
            <div class="prompt-help">
              2-30 characters, letters, numbers, and underscores only
            </div>
          </div>
        </div>
        <div class="custom-prompt-footer">
          <button
            id="confirm-username-btn"
            class="prompt-btn prompt-btn-primary"
          >
            Confirm Username
          </button>
        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="module">
      // Immediate authentication check - prevent any access without login
      let authCheckComplete = false;

      // Firebase SDK imports
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import {
        getFirestore,
        doc,
        setDoc,
        getDoc,
        Timestamp,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
      import {
        getAuth,
        onAuthStateChanged,
        signOut,
        updateProfile,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
      // Gemini SDK imports
      import {
        GoogleGenerativeAI,
        HarmCategory,
        HarmBlockThreshold,
      } from "https://esm.run/@google/generative-ai";
      // Simple username management - no complex profile system needed

      // --- Firebase Configuration ---
      const firebaseConfig = {
        apiKey: "AIzaSyAdhOUKDc-whz2Gh353E1ItT6XIjyuw4Ag", // Replace with your actual Firebase API key
        authDomain: "aitasker-fd519.firebaseapp.com",
        projectId: "aitasker-fd519",
        storageBucket: "aitasker-fd519.appspot.com",
        messagingSenderId: "48786270155",
        appId: "1:48786270155:web:3547fea3ded48f5dc8b84e",
        measurementId: "G-NQD5X1XVYD",
      };
      const firebaseApp = initializeApp(firebaseConfig);
      const db = getFirestore(firebaseApp);
      const auth = getAuth(firebaseApp);

      // Immediate authentication check - redirect if no user session
      auth.onAuthStateChanged((user) => {
        if (!user && !authCheckComplete) {
          console.log(
            "No user session found, redirecting to landing page immediately"
          );
          window.location.replace("landingpage.html");
        }
      });

      // --- Gemini Configuration ---
      const GEMINI_API_KEY = "AIzaSyD77R_RwPvjtRkdeY87nS1bBtDdjp6CJZc"; // Replace with your actual Gemini API key
      const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
      const geminiModel = genAI.getGenerativeModel({
        model: "gemini-1.5-flash",
      });
      const generationConfig = {
        temperature: 0.6,
        topP: 0.95,
        topK: 64,
        maxOutputTokens: 8192,
        responseMimeType: "application/json",
      };
      const safetySettings = [
        {
          category: HarmCategory.HARM_CATEGORY_HARASSMENT,
          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
        },
        {
          category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
        },
        {
          category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
        },
        {
          category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
        },
      ];

      // --- App State ---
      let currentUser = null;
      let yourname = "No Name";
      let tasksForCurrentSession = [];
      let analyzedTaskDataForSelectedDate = null;
      let selectedDate = new Date();
      let completionByCategoryChartInstance = null;
      let completedTasksTracker = new Set(); // Track completed carried-forward tasks

      // --- DOM Elements ---
      const taskInputModalEl = document.getElementById("task-input-modal");
      const taskModalContentEl =
        taskInputModalEl.querySelector(".modal-content");
      const modalTitleEl = document.getElementById("modal-title");
      const greetingMessageModalEl = document.getElementById(
        "greeting-message-modal"
      );
      const taskInputFieldModal = document.getElementById(
        "task-input-field-modal"
      );
      const currentTasksListModalEl = document.getElementById(
        "current-tasks-list-modal"
      );
      const cancelAddTaskBtn = document.getElementById("cancel-add-task-btn");
      const addCurrentTaskModalBtn = document.getElementById(
        "add-current-task-modal-btn"
      );
      const analyzeTasksModalBtn = document.getElementById(
        "analyze-tasks-modal-btn"
      );
      const heroAddTaskBtn = document.getElementById(
        "header-add-task-btn-main"
      );

      const currentDateDisplayEl = document.getElementById(
        "current-date-display"
      );
      const currentDateInputEl = document.getElementById("current-date-input");
      const prevDayBtn = document.getElementById("prev-day-btn");
      const nextDayBtn = document.getElementById("next-day-btn");
      const calendarIconBtn = document.getElementById("calendar-icon-btn");

      const loadingSpinner = document.getElementById("loading-spinner");
      const tasksCreatedEl = document.getElementById("tasks-created-today");
      const tasksCompletedEl = document.getElementById("tasks-completed");
      const tasksRemainingEl = document.getElementById("tasks-remaining");
      const taskColumnsContainer = document.getElementById(
        "task-columns-container"
      );
      const taskBehaviouralAnalysisSection = document.getElementById(
        "task-behavioural-analysis"
      );
      const toggleBehaviourAnalysisBtn = document.getElementById(
        "toggle-behaviour-analysis-btn"
      );

      // Carry Forward Elements
      const carryForwardContainer = document.getElementById(
        "carry-forward-container"
      );
      const addPreviousTasksBtn = document.getElementById(
        "add-previous-tasks-btn"
      );
      const fetchAgainBtn = document.getElementById("fetch-again-btn");
      const previousTasksCountEl = document.getElementById(
        "previous-tasks-count"
      );
      const carryForwardLoading = document.getElementById(
        "carry-forward-loading"
      );
      const carryForwardResult = document.getElementById(
        "carry-forward-result"
      );
      const carryForwardProgress = document.getElementById(
        "carry-forward-progress"
      );
      const backToTasksFromBehaviourBtn = document.getElementById(
        "back-to-tasks-from-behaviour-btn"
      );
      const behaviouralAnalysisDateDisplayEl = document.getElementById(
        "behavioural-analysis-date-display"
      );
      const behaviourCompletionRateEl = document.getElementById(
        "behaviour-completion-rate"
      );
      const behaviourCompletionProgressBarEl = document.getElementById(
        "behaviour-completion-progress-bar"
      );
      const focusCategoryBehaviourEl = document.getElementById(
        "focus-category-behaviour"
      );
      const infoModalEl = document.getElementById("info-modal");
      const infoModalContentEl = infoModalEl.querySelector(".modal-content");
      const infoIconBtn = document.getElementById("header-info-icon-btn");
      const infoModalCloseBtn = document.getElementById("info-modal-close-btn");
      const infoModalCloseXBtn = document.getElementById(
        "info-modal-close-x-btn"
      );

      // Focus Mode Elements
      const focusModeBtn = document.getElementById("focus-mode-btn");
      const focusModeModal = document.getElementById("focus-mode-modal");
      const focusModeModalContent = document.getElementById(
        "focus-mode-modal-content"
      );
      const focusModeCloseBtn = document.getElementById("focus-mode-close-btn");
      const focusTimerDisplay = document.getElementById("focus-timer-display");
      const focusStartBtn = document.getElementById("focus-start-btn");
      const focusPauseBtn = document.getElementById("focus-pause-btn");
      const focusResetBtn = document.getElementById("focus-reset-btn");

      // Mood Selection Elements
      const moodSelectionModal = document.getElementById(
        "mood-selection-modal"
      );
      const skipMoodBtn = document.getElementById("skip-mood-btn");

      // Name Elements
      const nameSection = document.getElementById("username-section");
      const nameDisplayElement = document.getElementById("username-display");
      const nameDropdown = document.getElementById("username-dropdown");
      const logoutBtn = document.getElementById("logout-btn");

      // Mood Analytics Chart Instance
      let moodAnalyticsChartInstance = null;

      const categoryUiMap = {
        "Very Important Tasks": {
          listEl: document.querySelector("#very-important-column ul"),
          quoteEl: document.getElementById("quote-very-important"),
          columnEl: document.getElementById("very-important-column"),
          color: "var(--accent-blue)",
        },
        "High Priority Tasks": {
          listEl: document.querySelector("#high-priority-column ul"),
          quoteEl: document.getElementById("quote-high-priority"),
          columnEl: document.getElementById("high-priority-column"),
          color: "var(--accent-red)",
        },
        "Good-Good Priority": {
          listEl: document.querySelector("#good-good-priority-column ul"),
          quoteEl: document.getElementById("quote-good-good"),
          columnEl: document.getElementById("good-good-priority-column"),
          color: "var(--accent-yellow)",
        },
        "Low Priority Tasks": {
          listEl: document.querySelector("#low-priority-column ul"),
          quoteEl: document.getElementById("quote-low-priority"),
          columnEl: document.getElementById("low-priority-column"),
          color: "var(--accent-purple)",
        },
      };

      // --- Utility Functions ---
      function formatDate(date) {
        return date.toLocaleDateString("en-CA");
      }
      function formatDateForDisplay(date) {
        const options = { year: "numeric", month: "long", day: "numeric" };
        return date.toLocaleDateString("en-US", options);
      }
      function showLoading(isLoading) {
        loadingSpinner.classList.toggle("hidden", !isLoading);
      }
      // Alert functions removed for faster silent experience
      // All operations now run in background without user interruption

      // --- Animation Initializations ---
      function initAnimations() {
        // AOS removed for better performance - tasks now appear instantly
        if (
          typeof Typed === "function" &&
          document.getElementById("hero-animated-title")
        ) {
          new Typed("#hero-animated-title", {
            strings: [
              "Precision Task Management",
              "AI-Driven Priority Analysis",
              "Objective Decision Support",
              "Strategic Workflow Optimization",
              "Enhanced Productivity Intelligence",
            ],
            typeSpeed: 50,
            backSpeed: 25,
            loop: true,
            smartBackspace: true,
            showCursor: true,
            cursorChar:
              '<span style="color: var(--ph-new-dark-green); font-weight: 300;">|</span>',
          });
        }

        const logoIcon = document.querySelector(".logo-placeholder"); // Target only the icon
        if (logoIcon) {
          gsap.to(logoIcon, {
            y: "-2px",
            duration: 1.5,
            repeat: -1,
            yoyo: true,
            ease: "sine.inOut",
          });
        }

        // Tilt effects disabled to prevent errors
        function initializeTiltEffects() {
          // Tilt effects completely disabled
          return;
        }

        initializeTiltEffects();
        if (typeof $ !== "undefined" && typeof $.fn.lettering === "function") {
          const behaviouralTitleEl =
            document.getElementById("behavioural-title");
          if (behaviouralTitleEl) $(behaviouralTitleEl).lettering();
        }
        if (typeof particlesJS !== "undefined") {
          particlesJS("particles-js", {
            particles: {
              number: { value: 25, density: { enable: true, value_area: 900 } },
              color: { value: ["#D5D8D3", "#E0E3DD", "#C8CBC5"] },
              shape: { type: "circle" },
              opacity: { value: 0.25, random: true, anim: { enable: false } },
              size: { value: 2.5, random: true, anim: { enable: false } },
              line_linked: {
                enable: true,
                distance: 200,
                color: "#DDE0DB",
                opacity: 0.1,
                width: 1,
              },
              move: {
                enable: true,
                speed: 0.8,
                direction: "none",
                random: true,
                straight: false,
                out_mode: "out",
                bounce: false,
              },
            },
            interactivity: {
              detect_on: "canvas",
              events: {
                onhover: { enable: true, mode: "repulse" },
                onclick: { enable: false },
                resize: true,
              },
              modes: { repulse: { distance: 40, duration: 0.3 } },
            },
            retina_detect: true,
          });
        }
      }

      // --- Date Management ---
      function showDatePicker() {
        currentDateDisplayEl.classList.add("hidden");
        calendarIconBtn.classList.add("hidden");
        currentDateInputEl.classList.remove("hidden");
        currentDateInputEl.value = formatDate(selectedDate);
        try {
          currentDateInputEl.showPicker();
        } catch (e) {
          currentDateInputEl.focus();
        }
      }

      function hideDatePicker() {
        currentDateInputEl.classList.add("hidden");
        currentDateDisplayEl.classList.remove("hidden");
        calendarIconBtn.classList.remove("hidden");
      }

      async function updateDateDisplayAndLoadTasks() {
        currentDateDisplayEl.textContent = formatDateForDisplay(selectedDate);
        if (behaviouralAnalysisDateDisplayEl)
          behaviouralAnalysisDateDisplayEl.textContent =
            formatDateForDisplay(selectedDate);
        await loadTasksForDate(selectedDate);
        if (
          taskBehaviouralAnalysisSection &&
          !taskBehaviouralAnalysisSection.classList.contains("hidden")
        ) {
          loadAndDisplayBehaviouralAnalysis();
        }
      }
      prevDayBtn.addEventListener("click", () => {
        selectedDate.setDate(selectedDate.getDate() - 1);
        updateDateDisplayAndLoadTasks();
      });

      nextDayBtn.addEventListener("click", () => {
        selectedDate.setDate(selectedDate.getDate() + 1);
        updateDateDisplayAndLoadTasks();
      });

      currentDateDisplayEl.addEventListener("click", showDatePicker);
      calendarIconBtn.addEventListener("click", showDatePicker);

      currentDateInputEl.addEventListener("change", (e) => {
        const [y, m, d] = e.target.value.split("-");
        selectedDate = new Date(y, m - 1, d);
        updateDateDisplayAndLoadTasks();
      });
      currentDateInputEl.addEventListener("blur", () => {
        setTimeout(hideDatePicker, 100);
      });

      // --- Task Input Modal Logic ---
      function openTaskModal() {
        // Remove hidden class and add visible class for proper CSS transitions
        taskInputModalEl.classList.remove("hidden");
        taskInputModalEl.classList.add("visible");

        // Animate the modal content with GSAP
        gsap.fromTo(
          taskModalContentEl,
          { y: 25, scale: 0.96, opacity: 0 },
          {
            duration: 0.35,
            y: 0,
            scale: 1,
            opacity: 1,
            delay: 0.05,
            ease: "back.out(1.6)",
          }
        );

        // Focus and setup modal content
        setTimeout(() => taskInputFieldModal.focus(), 100); // Small delay to ensure modal is visible
        tasksForCurrentSession = [];
        renderTasksForCurrentSession();
        greetingMessageModalEl.textContent = `Adding tasks for ${formatDateForDisplay(
          selectedDate
        )}. What's next, ${yourname}?`;
        modalTitleEl.textContent = `Add Tasks: ${formatDateForDisplay(
          selectedDate
        )}`;
      }

      function closeTaskModal() {
        gsap.to(taskModalContentEl, {
          duration: 0.25,
          y: 25,
          scale: 0.96,
          opacity: 0,
          ease: "power2.in",
          onComplete: () => {
            taskInputModalEl.classList.remove("visible");
            taskInputModalEl.classList.add("hidden");
          },
        });
        taskInputFieldModal.value = "";
      }
      if (heroAddTaskBtn)
        heroAddTaskBtn.addEventListener("click", openTaskModal);
      if (cancelAddTaskBtn)
        cancelAddTaskBtn.addEventListener("click", closeTaskModal);

      // --- Info Modal Logic ---
      function openInfoModal() {
        // Prevent body scroll on mobile when modal is open
        document.body.style.overflow = "hidden";

        // Remove hidden class and add visible class for proper CSS transitions
        infoModalEl.classList.remove("hidden");
        infoModalEl.classList.add("visible");

        // Reset scroll position to top
        infoModalContentEl.scrollTop = 0;

        // Animate the modal content with GSAP
        gsap.fromTo(
          infoModalContentEl,
          { y: 25, scale: 0.96, opacity: 0 },
          {
            duration: 0.35,
            y: 0,
            scale: 1,
            opacity: 1,
            delay: 0.05,
            ease: "back.out(1.6)",
          }
        );
      }

      function closeInfoModal() {
        // Restore body scroll
        document.body.style.overflow = "";

        gsap.to(infoModalContentEl, {
          duration: 0.25,
          y: 25,
          scale: 0.96,
          opacity: 0,
          ease: "power2.in",
          onComplete: () => {
            infoModalEl.classList.remove("visible");
            infoModalEl.classList.add("hidden");
          },
        });
      }

      // Handle modal backdrop clicks for mobile
      function handleInfoModalBackdropClick(event) {
        if (event.target === infoModalEl) {
          closeInfoModal();
        }
      }

      // Handle escape key for modal closing
      function handleInfoModalEscapeKey(event) {
        if (
          event.key === "Escape" &&
          !infoModalEl.classList.contains("hidden")
        ) {
          closeInfoModal();
        }
      }

      // Touch event support for mobile devices
      function addTouchSupport() {
        // Add touch event listeners for better mobile interaction
        if (infoModalCloseXBtn) {
          infoModalCloseXBtn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            closeInfoModal();
          });
        }

        if (infoModalCloseBtn) {
          infoModalCloseBtn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            closeInfoModal();
          });
        }

        // Prevent modal content from closing when touched
        if (infoModalContentEl) {
          infoModalContentEl.addEventListener("click", (e) => {
            e.stopPropagation();
          });
          infoModalContentEl.addEventListener("touchstart", (e) => {
            e.stopPropagation();
          });
        }
      }
      // Info Modal Event Listeners
      if (infoIconBtn) infoIconBtn.addEventListener("click", openInfoModal);
      if (infoModalCloseBtn)
        infoModalCloseBtn.addEventListener("click", closeInfoModal);
      if (infoModalCloseXBtn)
        infoModalCloseXBtn.addEventListener("click", closeInfoModal);

      // Modal backdrop click to close
      if (infoModalEl) {
        infoModalEl.addEventListener("click", handleInfoModalBackdropClick);
      }

      // Escape key to close modal
      document.addEventListener("keydown", handleInfoModalEscapeKey);

      // --- Focus Mode Logic ---
      let focusTimer = null;
      let focusTimeRemaining = 25 * 60; // 25 minutes in seconds
      let isFocusModeActive = false;
      let isPaused = false;

      function openFocusModeModal() {
        focusModeModal.classList.remove("hidden");
        focusModeModal.classList.add("visible");

        gsap.fromTo(
          focusModeModalContent,
          { y: 25, scale: 0.96, opacity: 0 },
          {
            duration: 0.35,
            y: 0,
            scale: 1,
            opacity: 1,
            delay: 0.05,
            ease: "back.out(1.6)",
          }
        );
      }

      function closeFocusModeModal() {
        gsap.to(focusModeModalContent, {
          duration: 0.25,
          y: 25,
          scale: 0.96,
          opacity: 0,
          ease: "power2.in",
          onComplete: () => {
            focusModeModal.classList.remove("visible");
            focusModeModal.classList.add("hidden");
          },
        });
      }

      function startFocusMode() {
        if (!isFocusModeActive) {
          isFocusModeActive = true;
          isPaused = false;
          document.body.classList.add("focus-mode-active");

          focusStartBtn.style.display = "none";
          focusPauseBtn.style.display = "inline-flex";

          focusTimer = setInterval(() => {
            if (!isPaused) {
              focusTimeRemaining--;
              updateFocusTimerDisplay();

              if (focusTimeRemaining <= 0) {
                endFocusSession();
              }
            }
          }, 1000);

          closeFocusModeModal();
          // Focus mode activated silently
        }
      }

      function pauseFocusMode() {
        isPaused = !isPaused;
        focusPauseBtn.innerHTML = isPaused
          ? '<i class="fas fa-play"></i> Resume'
          : '<i class="fas fa-pause"></i> Pause';
      }

      function resetFocusMode() {
        clearInterval(focusTimer);
        focusTimeRemaining = 25 * 60;
        isFocusModeActive = false;
        isPaused = false;
        document.body.classList.remove("focus-mode-active");

        focusStartBtn.style.display = "inline-flex";
        focusPauseBtn.style.display = "none";
        focusPauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';

        updateFocusTimerDisplay();
      }

      function endFocusSession() {
        resetFocusMode();
        // Focus session completed silently
      }

      function updateFocusTimerDisplay() {
        const minutes = Math.floor(focusTimeRemaining / 60);
        const seconds = focusTimeRemaining % 60;
        focusTimerDisplay.textContent = `${minutes
          .toString()
          .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
      }

      // --- Mood Analytics Logic ---
      async function loadMoodDataFromFirestore(date) {
        if (!currentUser) {
          return [];
        }

        try {
          const dateStr = formatDate(date);
          const moodDocRef = doc(
            db,
            "user-moods",
            `${currentUser.uid}-${dateStr}`
          );
          const moodDoc = await getDoc(moodDocRef);

          if (moodDoc.exists()) {
            return moodDoc.data().moods || [];
          }
          return [];
        } catch (error) {
          console.error("Error loading mood data from Firestore:", error);
          return [];
        }
      }

      async function loadAnalyticsData() {
        // Calculate analytics metrics
        const metrics = await calculateAnalyticsMetrics();
        updateAnalyticsMetrics(metrics);
      }

      async function calculateAnalyticsMetrics() {
        // This would typically fetch data from Firebase for multiple dates
        // For now, we'll use current date data and simulate historical data
        const currentData = analyzedTaskDataForSelectedDate;

        let totalTasks = 0;
        let completedTasks = 0;
        let moodData = {};

        if (currentData) {
          Object.keys(categoryUiMap).forEach((categoryKey) => {
            const tasks = currentData[categoryKey];
            if (tasks && Array.isArray(tasks)) {
              tasks.forEach((task) => {
                totalTasks++;
                if (task.completed) {
                  completedTasks++;
                  if (task.mood) {
                    moodData[task.mood] = (moodData[task.mood] || 0) + 1;
                  }
                }
              });
            }
          });
        }

        const completionRate =
          totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
        const avgMood =
          Object.keys(moodData).length > 0
            ? getMostFrequentMood(moodData)
            : "";

        return {
          currentStreak: 1, // Simplified for demo
          completionRate,
          avgTasksPerDay: Math.round(totalTasks * 0.8), // Simulated average
          avgMood,
          totalTasks,
          completedTasks,
          moodData,
        };
      }

      function getMostFrequentMood(moodData) {
        const moodEmojis = {
          accomplished: "",
          happy: "",
          relieved: "",
          neutral: "",
          stressed: "",
          frustrated: "",
        };

        let maxCount = 0;
        let mostFrequent = "happy";

        Object.entries(moodData).forEach(([mood, count]) => {
          if (count > maxCount) {
            maxCount = count;
            mostFrequent = mood;
          }
        });

        return moodEmojis[mostFrequent] || "";
      }

      function updateAnalyticsMetrics(metrics) {
        document.getElementById(
          "current-streak"
        ).textContent = `${metrics.currentStreak} days`;
        document.getElementById(
          "avg-completion-rate"
        ).textContent = `${metrics.completionRate}%`;
        document.getElementById("avg-tasks-per-day").textContent =
          metrics.avgTasksPerDay;
        document.getElementById("avg-mood-score").textContent = metrics.avgMood;
      }

      async function renderMoodAnalyticsChart() {
        const ctx = document
          .getElementById("moodAnalyticsChart")
          ?.getContext("2d");
        if (!ctx) {
          console.error("moodAnalyticsChart canvas not found");
          return;
        }

        // Destroy existing chart
        if (moodAnalyticsChartInstance) {
          moodAnalyticsChartInstance.destroy();
        }

        // Load mood data from Firestore
        const moodEntries = await loadMoodDataFromFirestore(selectedDate);

        // Count mood frequencies
        const moodCounts = {
          accomplished: 0,
          happy: 0,
          relieved: 0,
          neutral: 0,
          stressed: 0,
          frustrated: 0,
        };

        moodEntries.forEach((entry) => {
          if (moodCounts.hasOwnProperty(entry.mood)) {
            moodCounts[entry.mood]++;
          }
        });

        // Prepare chart data with emojis
        const labels = [
          " Accomplished",
          " Happy",
          " Relieved",
          " Neutral",
          " Stressed",
          " Frustrated",
        ];

        const data = Object.values(moodCounts);
        const colors = [
          "#F59E0B", // Accomplished - Gold
          "#10B981", // Happy - Green
          "#6366F1", // Relieved - Indigo
          "#6B7280", // Neutral - Gray
          "#F97316", // Stressed - Orange
          "#EF4444", // Frustrated - Red
        ];

        const isMobile = window.innerWidth < 768;

        moodAnalyticsChartInstance = new Chart(ctx, {
          type: "doughnut",
          data: {
            labels: labels,
            datasets: [
              {
                data: data,
                backgroundColor: colors,
                borderWidth: 2,
                borderColor: "#ffffff",
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: isMobile ? "bottom" : "right",
                labels: {
                  color: "var(--ph-new-text-dark)",
                  font: {
                    size: isMobile ? 10 : 12,
                    family: "Poppins",
                  },
                  padding: isMobile ? 10 : 15,
                  usePointStyle: true,
                  pointStyle: "circle",
                },
              },
              tooltip: {
                backgroundColor: "rgba(255, 255, 255, 0.95)",
                titleColor: "#1f2937",
                bodyColor: "#374151",
                borderColor: "#d1d5db",
                borderWidth: 1,
                titleFont: { family: "Poppins", weight: "600" },
                bodyFont: { family: "Poppins" },
                callbacks: {
                  label: function (context) {
                    const total = context.dataset.data.reduce(
                      (a, b) => a + b,
                      0
                    );
                    const percentage =
                      total > 0
                        ? Math.round((context.parsed / total) * 100)
                        : 0;
                    return `${context.label}: ${context.parsed} (${percentage}%)`;
                  },
                },
              },
            },
            animation: {
              duration: 700,
              easing: "easeOutQuart",
            },
          },
        });
      }

      // --- Charts Initialization ---
      function initializeCharts() {
        initCompletionTrendsChart();
        initPriorityDistributionChart();
        initBurndownChart();
        initMoodAnalyticsChart();
      }

      function initCompletionTrendsChart() {
        const ctx = document
          .getElementById("completion-trends-chart")
          .getContext("2d");

        // Simulate 7 days of data
        const labels = [];
        const data = [];
        for (let i = 6; i >= 0; i--) {
          const date = new Date();
          date.setDate(date.getDate() - i);
          labels.push(date.toLocaleDateString("en-US", { weekday: "short" }));
          data.push(Math.floor(Math.random() * 10) + 5); // Random data for demo
        }

        analyticsCharts.completionTrends = new Chart(ctx, {
          type: "line",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Tasks Completed",
                data: data,
                borderColor: "rgb(75, 192, 192)",
                backgroundColor: "rgba(75, 192, 192, 0.2)",
                tension: 0.4,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false,
              },
            },
          },
        });
      }

      function initPriorityDistributionChart() {
        const ctx = document
          .getElementById("priority-distribution-chart")
          .getContext("2d");

        let data = [0, 0, 0, 0];
        if (analyzedTaskDataForSelectedDate) {
          const categories = [
            "Very Important Tasks",
            "High Priority Tasks",
            "Good-Good Priority",
            "Low Priority Tasks",
          ];
          categories.forEach((category, index) => {
            const tasks = analyzedTaskDataForSelectedDate[category];
            data[index] = tasks ? tasks.length : 0;
          });
        }

        analyticsCharts.priorityDistribution = new Chart(ctx, {
          type: "doughnut",
          data: {
            labels: [
              "Very Important",
              "High Priority",
              "Good Priority",
              "Low Priority",
            ],
            datasets: [
              {
                data: data,
                backgroundColor: [
                  "#3B82F6", // Blue
                  "#EF4444", // Red
                  "#F59E0B", // Yellow
                  "#8B5CF6", // Purple
                ],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
          },
        });
      }

      function initBurndownChart() {
        const ctx = document.getElementById("burndown-chart").getContext("2d");

        // Simulate burndown data
        const labels = [
          "Day 1",
          "Day 2",
          "Day 3",
          "Day 4",
          "Day 5",
          "Day 6",
          "Day 7",
        ];
        const idealData = [20, 17, 14, 11, 8, 5, 2];
        const actualData = [20, 16, 15, 12, 9, 7, 3];

        analyticsCharts.burndown = new Chart(ctx, {
          type: "line",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Ideal",
                data: idealData,
                borderColor: "#10B981",
                backgroundColor: "rgba(16, 185, 129, 0.1)",
                borderDash: [5, 5],
              },
              {
                label: "Actual",
                data: actualData,
                borderColor: "#3B82F6",
                backgroundColor: "rgba(59, 130, 246, 0.1)",
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "Remaining Tasks",
                },
              },
            },
          },
        });
      }

      function initMoodAnalyticsChart() {
        const ctx = document
          .getElementById("mood-analytics-chart")
          .getContext("2d");

        // Get mood data from current tasks
        let moodData = {
          accomplished: 0,
          happy: 0,
          relieved: 0,
          neutral: 0,
          stressed: 0,
          frustrated: 0,
        };

        if (analyzedTaskDataForSelectedDate) {
          Object.keys(categoryUiMap).forEach((categoryKey) => {
            const tasks = analyzedTaskDataForSelectedDate[categoryKey];
            if (tasks && Array.isArray(tasks)) {
              tasks.forEach((task) => {
                if (task.completed && task.mood) {
                  moodData[task.mood] = (moodData[task.mood] || 0) + 1;
                }
              });
            }
          });
        }

        analyticsCharts.moodAnalytics = new Chart(ctx, {
          type: "bar",
          data: {
            labels: [
              " Accomplished",
              " Happy",
              " Relieved",
              " Neutral",
              " Stressed",
              " Frustrated",
            ],
            datasets: [
              {
                label: "Task Completion Mood",
                data: Object.values(moodData),
                backgroundColor: [
                  "#F59E0B", // Accomplished
                  "#10B981", // Happy
                  "#6366F1", // Relieved
                  "#6B7280", // Neutral
                  "#F97316", // Stressed
                  "#EF4444", // Frustrated
                ],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false,
              },
              tooltip: {
                backgroundColor: "rgba(255, 255, 255, 0.95)",
                titleColor: "#1f2937",
                bodyColor: "#374151",
                borderColor: "#d1d5db",
                borderWidth: 1,
                titleFont: { family: "Poppins", weight: "600" },
                bodyFont: { family: "Poppins" },
              },
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  stepSize: 1,
                },
              },
            },
          },
        });
      }

      function updateCharts() {
        // Update charts when view changes
        if (analyticsCharts.priorityDistribution) {
          initPriorityDistributionChart();
        }
        if (analyticsCharts.moodAnalytics) {
          initMoodAnalyticsChart();
        }
      }

      // --- Mood Tracking Logic ---
      let currentTaskForMood = null;

      function showMoodSelection(taskItem, categoryKey) {
        currentTaskForMood = { taskItem, categoryKey };
        moodSelectionModal.classList.remove("hidden");
        moodSelectionModal.classList.add("visible");

        gsap.fromTo(
          moodSelectionModal.querySelector(".modal-content"),
          { y: 25, scale: 0.96, opacity: 0 },
          {
            duration: 0.35,
            y: 0,
            scale: 1,
            opacity: 1,
            delay: 0.05,
            ease: "back.out(1.6)",
          }
        );
      }

      function closeMoodSelection() {
        gsap.to(moodSelectionModal.querySelector(".modal-content"), {
          duration: 0.25,
          y: 25,
          scale: 0.96,
          opacity: 0,
          ease: "power2.in",
          onComplete: () => {
            moodSelectionModal.classList.remove("visible");
            moodSelectionModal.classList.add("hidden");
            currentTaskForMood = null;
          },
        });
      }

      async function selectMood(mood, emoji) {
        if (currentTaskForMood) {
          const { taskItem } = currentTaskForMood;

          // Show loading state
          showLoading(true);

          try {
            // Add mood to task data
            taskItem.mood = mood;
            taskItem.moodEmoji = emoji;
            taskItem.moodTimestamp = new Date().toISOString();

            // Add mood indicator to task UI
            addMoodIndicatorToTask(taskItem, emoji);

            // Perform all backend operations in sequence
            await Promise.all([
              saveTasksToFirestore(
                selectedDate,
                analyzedTaskDataForSelectedDate
              ),
              saveMoodToFirestore(selectedDate, mood, emoji, taskItem.task),
            ]);

            // Calculate and update streak after task completion
            await calculateAndUpdateStreak();

            closeMoodSelection();

            // No success popup - operations complete silently
          } catch (error) {
            console.error("Error completing task:", error);
            // Error handled silently - no popup shown to user
          } finally {
            showLoading(false);
          }

          // Update mood analytics if behavioral analysis is visible
          if (!taskBehaviouralAnalysisSection.classList.contains("hidden")) {
            loadAndDisplayBehaviouralAnalysis();
          }
        }
      }

      // --- SIMPLE USERNAME SETUP SYSTEM ---

      function checkIfUsernameNeeded() {
        // Simple check: if displayName is null or "Loading...", show setup
        if (!currentUser) return false;

        const currentDisplayName = currentUser.displayName;
        return !currentDisplayName || currentDisplayName === "Loading...";
      }

      async function loadUserDisplayName() {
        if (!currentUser) return;

        try {
          // Check Firebase Auth first
          if (
            currentUser.displayName &&
            currentUser.displayName !== "Loading..."
          ) {
            yourname = currentUser.displayName;
            updateNameDisplay();
            return;
          }

          // Check Firestore as fallback
          const userDocRef = doc(db, "users", currentUser.uid);
          const userDoc = await getDoc(userDocRef);

          if (userDoc.exists()) {
            const userData = userDoc.data();
            if (userData.displayName) {
              yourname = userData.displayName;
              // Update Firebase Auth too
              await updateProfile(currentUser, {
                displayName: userData.displayName,
              });
            } else {
              yourname = "User";
            }
          } else {
            yourname = "User";
          }

          updateNameDisplay();
        } catch (error) {
          console.error("Error loading username:", error);
          yourname = "User";
          updateNameDisplay();
        }
      }

      function showUsernameSetupPrompt() {
        // Show custom styled prompt
        const promptElement = document.getElementById("custom-username-prompt");
        const inputElement = document.getElementById("custom-username-input");
        const buttonElement = document.getElementById("confirm-username-btn");

        if (promptElement && inputElement && buttonElement) {
          promptElement.style.display = "flex";

          // Focus input after animation
          setTimeout(() => {
            inputElement.focus();
          }, 500);

          // Handle button click
          buttonElement.onclick = () => {
            const username = inputElement.value.trim();
            if (username) {
              saveUsernameDirectly(username);
            } else {
              alert("Please enter a username.");
            }
          };

          // Handle Enter key
          inputElement.onkeypress = (e) => {
            if (e.key === "Enter") {
              buttonElement.click();
            }
          };
        }
      }

      function hideUsernameSetupPrompt() {
        const promptElement = document.getElementById("custom-username-prompt");
        if (promptElement) {
          promptElement.style.display = "none";
        }
      }

      async function saveUsernameDirectly(username) {
        const buttonElement = document.getElementById("confirm-username-btn");

        // Validate username
        if (!username || username.length < 2 || username.length > 30) {
          alert("Username must be 2-30 characters long.");
          return;
        }

        if (!/^[a-zA-Z0-9_]+$/.test(username)) {
          alert("Username can only contain letters, numbers, and underscores.");
          return;
        }

        // Disable button during save
        if (buttonElement) {
          buttonElement.disabled = true;
          buttonElement.textContent = "Saving...";
        }

        try {
          // Update Firebase Auth immediately
          await updateProfile(currentUser, { displayName: username });

          // Update Firestore
          const userDocRef = doc(db, "users", currentUser.uid);
          await setDoc(
            userDocRef,
            {
              displayName: username,
              email: currentUser.email,
              usernameSetupComplete: true,
              createdAt: Timestamp.now(),
              lastUpdated: Timestamp.now(),
            },
            { merge: true }
          );

          // Update local state
          yourname = username;
          updateNameDisplay();

          // Hide prompt
          hideUsernameSetupPrompt();

          // Username set silently - no popup needed
        } catch (error) {
          console.error("Error saving username:", error);
          alert("Failed to save username. Please try again.");

          // Re-enable button
          if (buttonElement) {
            buttonElement.disabled = false;
            buttonElement.textContent = "Confirm Username";
          }
        }
      }

      function updateNameDisplay() {
        if (nameDisplayElement) {
          nameDisplayElement.textContent = yourname;
        }
      }

      function updateStreakDisplay(streakCount) {
        const streakCountElement = document.getElementById("streak-count");
        if (streakCountElement) {
          streakCountElement.textContent = streakCount || 0;
        }
      }

      // --- Carry Forward Functionality ---
      async function checkAndShowCarryForward() {
        if (!currentUser) return;

        try {
          // Show loading state
          showCarryForwardLoading(true);

          // Start timer for minimum loading time
          const startTime = Date.now();
          const minLoadingTime = 800; // Minimum 800ms loading

          // Get all incomplete tasks from previous dates
          const allIncompleteTasks = await getAllPreviousIncompleteTasks(false);

          // Filter out tasks that are already carried forward to current date
          const tasksNotYetCarriedForward =
            await filterAlreadyCarriedForwardTasks(allIncompleteTasks);

          // Ensure minimum loading time
          const elapsedTime = Date.now() - startTime;
          const remainingTime = Math.max(0, minLoadingTime - elapsedTime);

          setTimeout(() => {
            // Hide loading state
            showCarryForwardLoading(false);

            if (tasksNotYetCarriedForward.length > 0) {
              previousTasksCountEl.textContent =
                tasksNotYetCarriedForward.length;
              carryForwardContainer.style.display = "block";
            } else {
              carryForwardContainer.style.display = "none";
            }
          }, remainingTime);
        } catch (error) {
          console.error("Error checking carry forward:", error);
          showCarryForwardLoading(false);
          carryForwardContainer.style.display = "none";
        }
      }

      // Show/hide carry forward loading state
      function showCarryForwardLoading(show) {
        if (show) {
          carryForwardLoading.style.display = "flex";
          carryForwardResult.style.display = "none";
          carryForwardContainer.style.display = "block";

          // Animate progress bar
          let progress = 0;
          const progressInterval = setInterval(() => {
            progress += Math.random() * 15;
            if (progress > 90) progress = 90;
            carryForwardProgress.style.width = `${progress}%`;
          }, 200);

          // Store interval for cleanup
          carryForwardContainer.dataset.progressInterval = progressInterval;
        } else {
          // Complete the progress bar
          carryForwardProgress.style.width = "100%";

          // Clear interval
          const progressInterval =
            carryForwardContainer.dataset.progressInterval;
          if (progressInterval) {
            clearInterval(progressInterval);
            delete carryForwardContainer.dataset.progressInterval;
          }

          // Hide loading after a short delay
          setTimeout(() => {
            carryForwardLoading.style.display = "none";
            carryForwardResult.style.display = "block";
            carryForwardProgress.style.width = "0%";
          }, 300);
        }
      }

      // Filter out tasks that are already present in current date
      async function filterAlreadyCarriedForwardTasks(incompleteTasks) {
        if (!analyzedTaskDataForSelectedDate || incompleteTasks.length === 0) {
          return incompleteTasks;
        }

        const currentTasks = [];
        // Get all current tasks
        Object.keys(analyzedTaskDataForSelectedDate).forEach((category) => {
          if (Array.isArray(analyzedTaskDataForSelectedDate[category])) {
            analyzedTaskDataForSelectedDate[category].forEach((task) => {
              currentTasks.push({
                task: task.task,
                originalDate: task.originalDate,
                originalCategory: task.originalCategory || category,
              });
            });
          }
        });

        // Filter out tasks that are already present
        return incompleteTasks.filter((incompleteTask) => {
          return !currentTasks.some(
            (currentTask) =>
              currentTask.task === incompleteTask.task &&
              currentTask.originalDate === incompleteTask.originalDate &&
              currentTask.originalCategory === incompleteTask.originalCategory
          );
        });
      }

      // Get all incomplete tasks from all previous dates (last 30 days)
      async function getAllPreviousIncompleteTasks(countOnly = false) {
        if (!currentUser) return countOnly ? 0 : [];

        try {
          const allIncompleteTasks = [];
          let totalCount = 0;

          // Check last 30 days for incomplete tasks
          for (let i = 1; i <= 30; i++) {
            const checkDate = new Date(
              selectedDate.getTime() - i * 24 * 60 * 60 * 1000
            );
            const dateKey = formatDate(checkDate);

            try {
              const docRef = doc(
                db,
                "dailyTasks",
                `${currentUser.uid}-${dateKey}`
              );
              const docSnap = await getDoc(docRef);

              if (docSnap.exists()) {
                const data = docSnap.data();
                const incompleteTasks = getIncompleteTasks(data, dateKey);

                if (countOnly) {
                  totalCount += incompleteTasks.length;
                } else {
                  // Add date info to each task
                  incompleteTasks.forEach((task) => {
                    task.originalDate = dateKey;
                    task.daysSinceOriginal = i;
                    allIncompleteTasks.push(task);
                  });
                }
              }
            } catch (docError) {
              // Skip this date if there's an error (normal for dates with no data)
            }
          }

          if (countOnly) {
            return totalCount;
          }

          // Remove duplicates (filtering for completed tasks is now done in getIncompleteTasks)
          const uniqueTasks = [];
          const seenTasks = new Set();

          allIncompleteTasks.forEach((task) => {
            const taskKey =
              `${task.task}_${task.originalCategory}`.toLowerCase();

            // Skip if already seen (duplicate)
            if (seenTasks.has(taskKey)) {
              return;
            }

            // Add unique task (completion filtering already done in getIncompleteTasks)
            seenTasks.add(taskKey);
            uniqueTasks.push(task);
          });

          return uniqueTasks;
        } catch (error) {
          console.error("Error getting all previous incomplete tasks:", error);
          return countOnly ? 0 : [];
        }
      }

      function getIncompleteTasksCount(taskData) {
        if (!taskData) return 0;
        let incomplete = 0;
        Object.keys(taskData).forEach((category) => {
          if (Array.isArray(taskData[category])) {
            incomplete += taskData[category].filter(
              (task) => !task.completed
            ).length;
          }
        });
        return incomplete;
      }

      async function addPreviousIncompleteTasks() {
        if (!currentUser) return;

        try {
          showLoading(true);

          // Get all incomplete tasks from previous dates
          const allIncompleteTasks = await getAllPreviousIncompleteTasks(false);

          // Filter out tasks that are already carried forward
          const tasksToCarryForward = await filterAlreadyCarriedForwardTasks(
            allIncompleteTasks
          );

          if (tasksToCarryForward.length > 0) {
            // Add carry forward count to each task
            tasksToCarryForward.forEach((task) => {
              task.carryForwardCount = (task.carryForwardCount || 0) + 1;
              task.isCarriedForward = true;
              // daysSinceOriginal already calculated in getAllPreviousIncompleteTasks
            });

            // Merge with current day's tasks
            const mergedData = mergeCarryForwardTasks(
              analyzedTaskDataForSelectedDate,
              tasksToCarryForward
            );

            // Update the local data first
            analyzedTaskDataForSelectedDate = mergedData;

            // Save to Firestore (skip automatic UI update since we handle it manually)
            await saveTasksToFirestore(selectedDate, mergedData, true);

            // Force complete UI refresh with a small delay to ensure DOM updates
            setTimeout(() => {
              // Clear all task lists first to ensure clean render
              Object.values(categoryUiMap).forEach((ui) => {
                ui.listEl.innerHTML = "";
                ui.quoteEl.textContent = "";
              });

              // Then render with fresh data
              renderAnalyzedTasksUI();
              updateOverallProgressBar();
              updateDashboardUI();

              // Check carry forward again to hide button if no more tasks
              checkAndShowCarryForward();
            }, 50);

            // Tasks added silently - no popup needed
          } else {
            // No new tasks to carry forward - hide button silently
            carryForwardContainer.style.display = "none";
          }
        } catch (error) {
          console.error("Error adding carry forward tasks:", error);
          // Error handled silently - no popup shown to user
        } finally {
          showLoading(false);
        }
      }

      function getIncompleteTasks(taskData, dateKey = null) {
        const incompleteTasks = [];
        if (!taskData) return incompleteTasks;

        Object.keys(taskData).forEach((category) => {
          if (Array.isArray(taskData[category])) {
            taskData[category].forEach((task) => {
              // Primary check: task must not be completed in Firestore
              if (!task.completed) {
                // Create unique task ID for tracking completion across dates
                const taskId = dateKey
                  ? `${task.task}_${category}_${dateKey}`
                      .replace(/\s+/g, "_")
                      .toLowerCase()
                  : `${task.task}_${category}`
                      .replace(/\s+/g, "_")
                      .toLowerCase();

                // Create unique task key for completedTasksTracker check
                const uniqueTaskKey = `${task.task}_${category}`
                  .replace(/\s+/g, "_")
                  .toLowerCase();

                // Secondary check: also check completedTasksTracker for immediate session consistency
                // This handles cases where a task was just completed but Firestore hasn't been updated yet
                if (!completedTasksTracker.has(uniqueTaskKey)) {
                  incompleteTasks.push({
                    ...task,
                    originalCategory: category,
                    taskId: taskId,
                  });
                }
              }
            });
          }
        });
        return incompleteTasks;
      }

      function mergeCarryForwardTasks(currentData, carryForwardTasks) {
        const mergedData = currentData
          ? JSON.parse(JSON.stringify(currentData))
          : {};

        // Ensure quotes exist if we don't have current data
        if (!mergedData.quotes) {
          mergedData.quotes = {
            "Very Important Tasks": "Focus on what matters most! ",
            "High Priority Tasks": "High energy for high priority! ",
            "Good-Good Priority": "Steady progress on good tasks! ",
            "Low Priority Tasks": "Every small step counts! ",
          };
        }

        carryForwardTasks.forEach((task) => {
          const category = task.originalCategory;
          if (!mergedData[category]) {
            mergedData[category] = [];
          }
          mergedData[category].push(task);
        });

        return mergedData;
      }

      // Helper function for ordinal numbers
      function getOrdinal(num) {
        const suffixes = ["th", "st", "nd", "rd"];
        const v = num % 100;
        return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);
      }

      // Load and save completed tasks tracker
      function loadCompletedTasksTracker() {
        if (!currentUser) return;

        try {
          const saved = localStorage.getItem(
            `completedTasks_${currentUser.uid}`
          );
          if (saved) {
            completedTasksTracker = new Set(JSON.parse(saved));
          } else {
          }
        } catch (error) {
          console.error("Error loading completed tasks tracker:", error);
          completedTasksTracker = new Set();
        }
      }

      function saveCompletedTasksTracker() {
        if (!currentUser) return;

        try {
          localStorage.setItem(
            `completedTasks_${currentUser.uid}`,
            JSON.stringify([...completedTasksTracker])
          );
        } catch (error) {
          console.error("Error saving completed tasks tracker:", error);
        }
      }

      // Clean up old entries from completed tasks tracker (older than 60 days)
      function cleanupCompletedTasksTracker() {
        if (!currentUser) return;

        try {
          const cutoffDate = new Date();
          cutoffDate.setDate(cutoffDate.getDate() - 60); // 60 days ago
          const cutoffDateStr = formatDate(cutoffDate);

          const originalSize = completedTasksTracker.size;
          const cleanedTracker = new Set();

          completedTasksTracker.forEach((taskId) => {
            // Extract date from taskId (format: task_category_date)
            const parts = taskId.split("_");
            const dateStr = parts[parts.length - 1];

            // Keep entries that don't have date format or are recent enough
            if (
              !dateStr.match(/^\d{4}-\d{2}-\d{2}$/) ||
              dateStr >= cutoffDateStr
            ) {
              cleanedTracker.add(taskId);
            }
          });

          completedTasksTracker = cleanedTracker;

          if (originalSize !== completedTasksTracker.size) {
            saveCompletedTasksTracker();
          }
        } catch (error) {
          console.error("Error cleaning up completed tasks tracker:", error);
        }
      }

      // Debug function to clear completed tasks tracker (can be called from console)
      window.clearCompletedTasksTracker = function () {
        if (!currentUser) {
          console.log(" No authenticated user");
          return;
        }

        const originalSize = completedTasksTracker.size;
        completedTasksTracker.clear();
        saveCompletedTasksTracker();
        console.log(
          ` Cleared completed tasks tracker (had ${originalSize} entries)`
        );
      };

      // Debug function to show completed tasks tracker (can be called from console)
      window.showCompletedTasksTracker = function () {
        if (!currentUser) {
          console.log(" No authenticated user");
          return;
        }

        console.log(
          ` Completed tasks tracker (${completedTasksTracker.size} entries):`
        );
        [...completedTasksTracker].forEach((taskId) => {
          console.log(`  - ${taskId}`);
        });
      };

      // Handle completion of carried-forward tasks
      async function handleCarriedForwardTaskCompletion(taskItem) {
        if (!currentUser || !taskItem.originalDate) return;

        try {
          const currentDateStr = formatDate(selectedDate);

          // Add completion info to current task
          taskItem.completedOnDate = currentDateStr;
          taskItem.completionNote = `Completed on ${currentDateStr}`;

          // Create a unique task identifier based on task text and original category
          const uniqueTaskIdentifier =
            `${taskItem.task}_${taskItem.originalCategory}`
              .toLowerCase()
              .replace(/\s+/g, "_");

          // Find ALL dates where this task exists and update them
          await updateAllInstancesOfTask(
            uniqueTaskIdentifier,
            taskItem.task,
            taskItem.originalCategory,
            currentDateStr,
            true // mark as completed
          );
        } catch (error) {
          console.error(
            "Error handling carried-forward task completion:",
            error
          );
        }
      }

      // Handle uncompletion of carried-forward tasks
      async function handleCarriedForwardTaskUncompletion(taskItem) {
        if (!currentUser || !taskItem.originalDate) return;

        try {
          // Create a unique task identifier based on task text and original category
          const uniqueTaskIdentifier =
            `${taskItem.task}_${taskItem.originalCategory}`
              .toLowerCase()
              .replace(/\s+/g, "_");

          // Find ALL dates where this task exists and mark as uncompleted
          await updateAllInstancesOfTask(
            uniqueTaskIdentifier,
            taskItem.task,
            taskItem.originalCategory,
            null,
            false // mark as uncompleted
          );
        } catch (error) {
          console.error(
            "Error handling carried-forward task uncompletion:",
            error
          );
        }
      }

      // Update ALL instances of a task across all dates
      async function updateAllInstancesOfTask(
        uniqueTaskIdentifier,
        taskText,
        originalCategory,
        completedOnDate,
        isCompleted
      ) {
        if (!currentUser) return;

        try {
          // Search through the last 60 days to find all instances of this task
          const searchDays = 60;
          const updatePromises = [];

          for (let i = 0; i < searchDays; i++) {
            const checkDate = new Date(
              selectedDate.getTime() - i * 24 * 60 * 60 * 1000
            );
            const dateKey = formatDate(checkDate);

            // Create a promise for each date check and update
            const updatePromise = updateTaskInSpecificDate(
              dateKey,
              taskText,
              originalCategory,
              completedOnDate,
              isCompleted
            );
            updatePromises.push(updatePromise);
          }

          // Execute all updates in parallel for better performance
          await Promise.all(updatePromises);

          // Update completedTasksTracker for immediate filtering
          // Only add/remove the unique task identifier, not all date-specific IDs
          const uniqueTaskKey = `${taskText}_${originalCategory}`
            .replace(/\s+/g, "_")
            .toLowerCase();

          if (isCompleted) {
            completedTasksTracker.add(uniqueTaskKey);
          } else {
            completedTasksTracker.delete(uniqueTaskKey);
          }
          saveCompletedTasksTracker();
        } catch (error) {
          console.error("Error updating all instances of task:", error);
        }
      }

      // Update a task in a specific date's document
      async function updateTaskInSpecificDate(
        dateKey,
        taskText,
        originalCategory,
        completedOnDate,
        isCompleted
      ) {
        if (!currentUser) return;

        try {
          const docRef = doc(db, "dailyTasks", `${currentUser.uid}-${dateKey}`);
          const docSnap = await getDoc(docRef);

          if (docSnap.exists()) {
            const data = docSnap.data();
            let hasChanges = false;

            // Find and update the specific task
            if (
              data[originalCategory] &&
              Array.isArray(data[originalCategory])
            ) {
              data[originalCategory].forEach((task, index) => {
                if (task.task === taskText) {
                  if (isCompleted) {
                    // Mark as completed and add completion info
                    data[originalCategory][index].completed = true;
                    data[originalCategory][index].completedOnDate =
                      completedOnDate;
                    data[originalCategory][
                      index
                    ].completionNote = `Completed on ${completedOnDate}`;
                  } else {
                    // Mark as uncompleted and remove completion info
                    data[originalCategory][index].completed = false;
                    delete data[originalCategory][index].completedOnDate;
                    delete data[originalCategory][index].completionNote;
                  }
                  hasChanges = true;
                }
              });
            }

            // Save updated data back to Firestore only if there were changes
            if (hasChanges) {
              await setDoc(docRef, { ...data, lastUpdated: Timestamp.now() });
            }
          }
        } catch (error) {
          // Silently handle errors for dates that don't exist (normal case)
          // Only log if it's a real error, not a missing document
          if (error.code !== "not-found") {
            console.error(`Error updating task in date ${dateKey}:`, error);
          }
        }
      }

      // Handle abortion of carried-forward tasks (abortion = completion for tracking purposes)
      async function handleCarriedForwardTaskAbortion(taskItem) {
        if (!currentUser || !taskItem.originalDate) return;

        try {
          const currentDateStr = formatDate(selectedDate);

          // Create a unique task identifier based on task text and original category
          const uniqueTaskIdentifier =
            `${taskItem.task}_${taskItem.originalCategory}`
              .toLowerCase()
              .replace(/\s+/g, "_");

          // Find ALL dates where this task exists and mark as completed (aborted)
          await updateAllInstancesOfTask(
            uniqueTaskIdentifier,
            taskItem.task,
            taskItem.originalCategory,
            `${currentDateStr} (aborted)`,
            true // mark as completed
          );
        } catch (error) {
          console.error("Error handling carried-forward task abortion:", error);
        }
      }

      async function loadCurrentStreak() {
        if (!currentUser) return;

        try {
          const streakDocRef = doc(db, "userStreaks", currentUser.uid);
          const streakDoc = await getDoc(streakDocRef);

          if (streakDoc.exists()) {
            const streakData = streakDoc.data();
            updateStreakDisplay(streakData.currentStreak || 0);
          } else {
            updateStreakDisplay(0);
          }
        } catch (error) {
          console.error("Error loading streak:", error);
          updateStreakDisplay(0);
        }
      }

      function initializeNameDropdown() {
        if (!nameDisplayElement || !nameDropdown || !logoutBtn) return;

        // Name click to toggle dropdown
        nameDisplayElement.addEventListener("click", (e) => {
          e.stopPropagation();
          toggleNameDropdown();
        });

        // Logout button click
        logoutBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          handleLogout();
        });

        // Close dropdown when clicking outside
        document.addEventListener("click", (e) => {
          if (!nameSection.contains(e.target)) {
            closeNameDropdown();
          }
        });
      }

      function toggleNameDropdown() {
        if (nameDropdown.classList.contains("show")) {
          closeNameDropdown();
        } else {
          openNameDropdown();
        }
      }

      function openNameDropdown() {
        nameDropdown.classList.add("show");
      }

      function closeNameDropdown() {
        nameDropdown.classList.remove("show");
      }

      // --- Streak System ---
      async function calculateAndUpdateStreak() {
        if (!currentUser || !analyzedTaskDataForSelectedDate) return;

        try {
          const today = formatDate(selectedDate);
          const yesterday = formatDate(
            new Date(selectedDate.getTime() - 24 * 60 * 60 * 1000)
          );

          // Calculate completion rate for today
          const totalTasks = getTotalTasksCount(
            analyzedTaskDataForSelectedDate
          );
          const completedTasks = getCompletedTasksCount(
            analyzedTaskDataForSelectedDate
          );
          const completionRate =
            totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;

          // Check if user meets 70% threshold
          const meetsThreshold = completionRate >= 70;

          // Load streak data
          const streakDocRef = doc(db, "userStreaks", currentUser.uid);
          const streakDoc = await getDoc(streakDocRef);
          let streakData = streakDoc.exists()
            ? streakDoc.data()
            : {
                currentStreak: 0,
                lastUpdateDate: null,
                streakHistory: {},
              };

          // Update streak logic
          if (meetsThreshold) {
            if (streakData.lastUpdateDate === today) {
              // Same day, keep current streak (already counted)
              // No change needed
            } else if (streakData.lastUpdateDate === yesterday) {
              // Consecutive day - increment streak
              streakData.currentStreak += 1;
            } else {
              // First day or gap in streak - start new streak
              streakData.currentStreak = 1;
            }
          } else {
            // Threshold not met - reset streak
            if (streakData.lastUpdateDate !== today) {
              streakData.currentStreak = 0;
            }
          }

          // Update streak data
          streakData.lastUpdateDate = today;
          streakData.streakHistory[today] = {
            completionRate,
            meetsThreshold,
            totalTasks,
            completedTasks,
            timestamp: Timestamp.now(),
          };

          // Save to Firestore
          await setDoc(streakDocRef, streakData);

          // Update streak display in header
          updateStreakDisplay(streakData.currentStreak);
        } catch (error) {
          console.error("Error calculating streak:", error);
        }
      }

      function getTotalTasksCount(taskData) {
        if (!taskData) return 0;
        let total = 0;
        Object.keys(taskData).forEach((category) => {
          if (Array.isArray(taskData[category])) {
            // Aborted tasks are now completely removed, so no need to filter
            total += taskData[category].length;
          }
        });
        return total;
      }

      function getCompletedTasksCount(taskData) {
        if (!taskData) return 0;
        let completed = 0;
        Object.keys(taskData).forEach((category) => {
          if (Array.isArray(taskData[category])) {
            completed += taskData[category].filter(
              (task) => task.completed
            ).length;
          }
        });
        return completed;
      }

      // Save mood data separately for analytics
      async function saveMoodToFirestore(date, mood, emoji, taskText) {
        if (!currentUser) {
          console.error("No authenticated user for mood saving");
          return;
        }

        try {
          const dateStr = formatDate(date);
          const moodDocRef = doc(
            db,
            "user-moods",
            `${currentUser.uid}-${dateStr}`
          );

          // Get existing mood data for the day
          const moodDoc = await getDoc(moodDocRef);
          let moodData = moodDoc.exists() ? moodDoc.data() : { moods: [] };

          // Add new mood entry
          moodData.moods.push({
            mood: mood,
            emoji: emoji,
            task: taskText,
            timestamp: new Date().toISOString(),
          });

          // Save updated mood data
          await setDoc(moodDocRef, moodData);
        } catch (error) {
          console.error("Error saving mood to Firestore:", error);
        }
      }

      function addMoodIndicatorToTask(taskItem, emoji) {
        // Find the task element and add mood indicator
        const taskElements = document.querySelectorAll(".task-text");
        taskElements.forEach((element) => {
          if (element.textContent.trim() === taskItem.task) {
            // Remove existing mood indicator
            const existingMood = element.parentElement.querySelector(
              ".task-mood-indicator"
            );
            if (existingMood) {
              existingMood.remove();
            }

            // Add new mood indicator
            const moodIndicator = document.createElement("span");
            moodIndicator.className = "task-mood-indicator";
            moodIndicator.textContent = emoji;
            element.parentElement.appendChild(moodIndicator);
          }
        });
      }

      function renderTasksForCurrentSession() {
        currentTasksListModalEl.innerHTML = "";
        tasksForCurrentSession.forEach((taskText, index) => {
          const li = document.createElement("div");
          li.textContent = taskText;
          const removeBtn = document.createElement("i");
          removeBtn.className = "fas fa-times";
          removeBtn.onclick = () => {
            tasksForCurrentSession.splice(index, 1);
            renderTasksForCurrentSession();
          };
          li.appendChild(removeBtn);
          currentTasksListModalEl.appendChild(li);
        });
        analyzeTasksModalBtn.disabled = tasksForCurrentSession.length === 0;
      }
      addCurrentTaskModalBtn.addEventListener("click", () => {
        const taskText = taskInputFieldModal.value.trim();
        if (taskText) {
          tasksForCurrentSession.push(taskText);
          taskInputFieldModal.value = "";
          renderTasksForCurrentSession();
        }
        taskInputFieldModal.focus();
      });
      taskInputFieldModal.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          addCurrentTaskModalBtn.click();
        }
      });

      // --- Enhanced Gemini API Interaction with Refined Priority Classification ---
      async function callGeminiAPI(tasksToAnalyze) {
        const taskListString = tasksToAnalyze
          .map((task) => `- ${task}`)
          .join("\n");
        const currentDate = formatDateForDisplay(selectedDate);
        const prompt = `
            You are "PriorityHelp AI", an advanced task prioritization system. Analyze and categorize tasks using a multi-factor assessment framework for precise, AI-driven prioritization.

            TASKS TO ANALYZE:
            ${taskListString}

            DATE CONTEXT: ${currentDate}

            ENHANCED PRIORITY CLASSIFICATION FRAMEWORK:

            **VERY IMPORTANT TASKS** (Critical & Urgent - Score: 8-10)
            - Criteria: Hard deadlines TODAY, legal/financial consequences if missed, critical dependencies, career/health impact
            - Examples: Submit tax return (due today), Emergency medical appointment, Critical project deadline
            - Decision factors: Immediate consequences, irreversible impact, external dependencies

            **HIGH PRIORITY TASKS** (Important & Time-Sensitive - Score: 6-7)
            - Criteria: Significant impact on goals, time-sensitive opportunities, important relationships, skill development
            - Examples: Prepare for important meeting tomorrow, Apply for opportunity with deadline this week, Key client follow-up
            - Decision factors: Strategic value, relationship impact, opportunity cost

            **GOOD-GOOD PRIORITY** (Beneficial & Flexible - Score: 4-5)
            - Criteria: Personal development, wellness activities, relationship maintenance, skill building, optimization tasks
            - Examples: Exercise routine, Read industry article, Organize workspace, Learn new skill
            - Decision factors: Long-term benefit, personal growth, quality of life improvement

            **LOW PRIORITY TASKS** (Optional & Deferrable - Score: 1-3)
            - Criteria: Entertainment, non-essential activities, tasks with no clear deadline or minimal impact
            - Examples: Watch TV series, Browse social media, Reorganize old files, Casual browsing
            - Decision factors: Minimal impact if delayed, purely recreational, no external pressure

            ANALYSIS REQUIREMENTS:
            For EACH task, provide:
            1. EXACT original task text in "task" field
            2. Relevant emoji in "emoji" field
            3. Detailed "reason" (15-25 words) explaining the priority decision with specific criteria
            4. "priority_score" (1-10) based on urgency + importance + impact assessment
            5. "confidence" (1-10) indicating AI's certainty in the classification

            ENHANCED JSON STRUCTURE:
            {
              "Very Important Tasks": [ { "task": "...", "emoji": "...", "reason": "...", "priority_score": 9, "confidence": 8, "completed": false } ],
              "High Priority Tasks": [ { "task": "...", "emoji": "...", "reason": "...", "priority_score": 7, "confidence": 9, "completed": false } ],
              "Good-Good Priority": [ { "task": "...", "emoji": "...", "reason": "...", "priority_score": 5, "confidence": 8, "completed": false } ],
              "Low Priority Tasks": [ { "task": "...", "emoji": "...", "reason": "...", "priority_score": 2, "confidence": 9, "completed": false } ],
              "quotes": {
                "Very Important Tasks": "Focus on what truly moves the needle forward.",
                "High Priority Tasks": "Strategic actions that create meaningful progress.",
                "Good-Good Priority": "Investments in your future self and well-being.",
                "Low Priority Tasks": "Enjoy these when your important work is done."
              }
            }

            CLASSIFICATION RULES:
            - Consider deadlines, consequences, dependencies, and impact
            - Be objective and consistent in scoring
            - Provide specific, actionable reasoning
            - All 4 categories MUST be present (use [] if empty)
            - "task" field MUST exactly match user input
            - Output ONLY valid JSON`;
        try {
          const result = await geminiModel.generateContent({
            contents: [{ role: "user", parts: [{ text: prompt }] }],
            generationConfig,
            safetySettings,
          });
          const response = result.response;
          if (response.promptFeedback?.blockReason)
            throw new Error(
              `Gemini prompt blocked: ${response.promptFeedback.blockReason}`
            );
          if (response.candidates?.[0]?.finishReason === "SAFETY")
            throw new Error(`Gemini response blocked (SAFETY)`);
          const responseText =
            response.candidates?.[0]?.content?.parts?.[0]?.text;
          if (!responseText)
            throw new Error("Gemini returned no text content.");
          return JSON.parse(responseText);
        } catch (error) {
          console.error("Gemini API call failed:", error);
          // AI analysis error handled silently
          throw error;
        }
      }

      // --- Firestore Interaction ---
      async function saveTasksToFirestore(
        date,
        dataToSave,
        skipUIUpdate = false
      ) {
        if (!currentUser) {
          console.error("Authentication Error: Please log in to save tasks");
          return;
        }

        // Only show loading if we're not skipping UI updates (carry-forward handles loading separately)
        if (!skipUIUpdate) {
          showLoading(true);
        }

        try {
          const dateKey = formatDate(date);
          const docRef = doc(db, "dailyTasks", `${currentUser.uid}-${dateKey}`);
          await setDoc(docRef, { ...dataToSave, lastUpdated: Timestamp.now() });
          // Tasks saved silently - no popup needed

          // Only update UI if not skipped (for carry-forward we handle UI separately)
          if (!skipUIUpdate) {
            analyzedTaskDataForSelectedDate = dataToSave;
            renderAnalyzedTasksUI();
          }

          if (!taskBehaviouralAnalysisSection.classList.contains("hidden")) {
            loadAndDisplayBehaviouralAnalysis();
          }
        } catch (error) {
          console.error("Error saving tasks to Firestore:", error);
          // Database error handled silently
        } finally {
          // Only hide loading if we showed it
          if (!skipUIUpdate) {
            showLoading(false);
          }
        }
      }
      async function loadTasksForDate(date) {
        if (!currentUser) {
          analyzedTaskDataForSelectedDate = null;
          renderAnalyzedTasksUI();
          return;
        }

        showLoading(true);
        const dateKey = formatDate(date);
        try {
          const docRef = doc(db, "dailyTasks", `${currentUser.uid}-${dateKey}`);
          const docSnap = await getDoc(docRef);
          analyzedTaskDataForSelectedDate = docSnap.exists()
            ? docSnap.data()
            : null;
        } catch (error) {
          console.error("Error loading tasks from Firestore:", error);
          analyzedTaskDataForSelectedDate = null;
        } finally {
          renderAnalyzedTasksUI();
          showLoading(false);

          // Check for carry forward tasks after loading
          await checkAndShowCarryForward();
        }
      }

      // --- Main Task Processing & Rendering ---
      analyzeTasksModalBtn.addEventListener("click", async () => {
        if (tasksForCurrentSession.length === 0) {
          showErrorAlert("No New Tasks", "Please add tasks in the modal.");
          return;
        }
        showLoading(true);

        try {
          // Only analyze NEW tasks, not existing ones
          const newTasksAnalysis = await callGeminiAPI(tasksForCurrentSession);

          // Merge new tasks with existing data while preserving existing tasks
          const mergedData = mergeTaskData(
            analyzedTaskDataForSelectedDate,
            newTasksAnalysis
          );

          await saveTasksToFirestore(selectedDate, mergedData);

          // Animate new tasks into their categories
          animateNewTasksIntoCategories(newTasksAnalysis);

          // Clear the current session tasks since they've been processed
          tasksForCurrentSession = [];

          closeTaskModal();
        } catch (error) {
          console.error("Error in analyze/save process:", error);
        } finally {
          showLoading(false);
        }
      });

      // --- Task Data Merging Functions ---
      function mergeTaskData(existingData, newTasksData) {
        // If no existing data, return new data
        if (!existingData) {
          return newTasksData;
        }

        // Create a copy of existing data to preserve it
        const mergedData = JSON.parse(JSON.stringify(existingData));

        // Merge new tasks into existing categories
        Object.keys(categoryUiMap).forEach((categoryKey) => {
          if (
            newTasksData[categoryKey] &&
            Array.isArray(newTasksData[categoryKey])
          ) {
            // Initialize category if it doesn't exist
            if (!mergedData[categoryKey]) {
              mergedData[categoryKey] = [];
            }

            // Add new tasks to existing category
            mergedData[categoryKey].push(...newTasksData[categoryKey]);
          }
        });

        // Preserve or update quotes
        if (newTasksData.quotes) {
          mergedData.quotes = { ...mergedData.quotes, ...newTasksData.quotes };
        }

        return mergedData;
      }

      function animateNewTasksIntoCategories(newTasksData) {
        // Add smooth animation for new tasks appearing
        Object.keys(categoryUiMap).forEach((categoryKey) => {
          if (
            newTasksData[categoryKey] &&
            Array.isArray(newTasksData[categoryKey])
          ) {
            const categoryUI = categoryUiMap[categoryKey];
            const newTaskElements = categoryUI.listEl.querySelectorAll(
              "li:not([data-animated])"
            );

            newTaskElements.forEach((taskElement, index) => {
              taskElement.setAttribute("data-animated", "true");

              // Initial state: hidden and slightly offset
              gsap.set(taskElement, {
                opacity: 0,
                y: 20,
                scale: 0.95,
              });

              // Animate in with stagger
              gsap.to(taskElement, {
                opacity: 1,
                y: 0,
                scale: 1,
                duration: 0.5,
                delay: index * 0.1,
                ease: "back.out(1.7)",
              });
            });
          }
        });
      }

      function updateDashboardUI() {
        if (!analyzedTaskDataForSelectedDate) {
          tasksCreatedEl.textContent = "0";
          tasksCompletedEl.textContent = "0";
          tasksRemainingEl.textContent = "0";
          if (behaviourCompletionRateEl)
            behaviourCompletionRateEl.textContent = "0%";
          if (behaviourCompletionProgressBarEl)
            behaviourCompletionProgressBarEl.style.width = "0%";
          return;
        }
        let totalCreated = 0,
          totalCompleted = 0;
        Object.keys(categoryUiMap).forEach((categoryKey) => {
          const tasksInCategory = analyzedTaskDataForSelectedDate[categoryKey];
          if (tasksInCategory && Array.isArray(tasksInCategory)) {
            tasksInCategory.forEach((task) => {
              if (task && typeof task === "object" && "task" in task) {
                totalCreated++;
                if (task.completed) totalCompleted++;
              }
            });
          }
        });
        tasksCreatedEl.textContent = totalCreated;
        tasksCompletedEl.textContent = totalCompleted;
        tasksRemainingEl.textContent = totalCreated - totalCompleted;
        const completionPercentage =
          totalCreated > 0
            ? Math.round((totalCompleted / totalCreated) * 100)
            : 0;
        if (behaviourCompletionRateEl)
          behaviourCompletionRateEl.textContent = `${completionPercentage}%`;
        if (behaviourCompletionProgressBarEl)
          behaviourCompletionProgressBarEl.style.width = `${completionPercentage}%`;

        // Update streak when completion percentage changes
        if (currentUser && analyzedTaskDataForSelectedDate) {
          calculateAndUpdateStreak();
        }
      }

      function renderAnalyzedTasksUI() {
        Object.values(categoryUiMap).forEach((ui) => {
          ui.listEl.innerHTML = "";
          ui.quoteEl.textContent = "";
        });
        if (
          !analyzedTaskDataForSelectedDate ||
          !analyzedTaskDataForSelectedDate.quotes
        ) {
          updateDashboardUI();
          const defaultQuote =
            "Ready for your tasks! Let's make today amazing! ";
          Object.values(categoryUiMap).forEach(
            (ui) => (ui.quoteEl.textContent = defaultQuote)
          );
          return;
        }
        Object.keys(categoryUiMap).forEach((categoryKeyFromMap) => {
          const ui = categoryUiMap[categoryKeyFromMap];
          const tasksInCategory =
            analyzedTaskDataForSelectedDate[categoryKeyFromMap];
          const quote =
            analyzedTaskDataForSelectedDate.quotes[categoryKeyFromMap];

          if (
            tasksInCategory &&
            Array.isArray(tasksInCategory) &&
            tasksInCategory.length > 0
          ) {
            tasksInCategory.forEach((taskItem) => {
              const li = document.createElement("li");
              if (taskItem.completed) li.classList.add("completed");
              if (taskItem.isCarriedForward)
                li.classList.add("carried-forward");
              // Remove AOS attribute for instant visibility

              // Main content with task text and emoji
              const mainContentDiv = document.createElement("div");
              mainContentDiv.classList.add("task-main-content");
              const textAndEmojiDiv = document.createElement("div");
              textAndEmojiDiv.classList.add("task-text-and-emoji");
              const taskTextSpan = document.createElement("span");
              taskTextSpan.classList.add("task-text");
              taskTextSpan.textContent = taskItem.task;

              if (taskItem.emoji) {
                const emojiSpan = document.createElement("span");
                emojiSpan.classList.add("task-emoji");
                emojiSpan.textContent = taskItem.emoji;
                textAndEmojiDiv.appendChild(emojiSpan);
              }
              textAndEmojiDiv.insertBefore(
                taskTextSpan,
                textAndEmojiDiv.firstChild
              );
              mainContentDiv.appendChild(textAndEmojiDiv);

              // Task actions container
              const taskActions = document.createElement("div");
              taskActions.classList.add("task-actions");

              // Complete/incomplete toggle icon
              const tickIcon = document.createElement("i");
              tickIcon.classList.add(
                "fas",
                taskItem.completed ? "fa-check-circle" : "fa-circle",
                "task-complete-icon"
              );
              tickIcon.addEventListener("click", async (e) => {
                e.stopPropagation();

                taskItem.completed = !taskItem.completed;

                // Update UI immediately for better UX
                li.classList.toggle("completed", taskItem.completed);
                tickIcon.classList.toggle(
                  "fa-check-circle",
                  taskItem.completed
                );
                tickIcon.classList.toggle("fa-circle", !taskItem.completed);

                // Update progress bar immediately
                updateOverallProgressBar();
                updateDashboardUI();

                // Show mood selection for completed tasks
                if (taskItem.completed) {
                  showMoodSelection(taskItem, categoryKeyFromMap);

                  // If this is a carried-forward task, handle completion properly
                  if (taskItem.isCarriedForward && taskItem.originalDate) {
                    await handleCarriedForwardTaskCompletion(taskItem);
                  }
                } else {
                  // Remove mood if task is uncompleted
                  delete taskItem.mood;
                  delete taskItem.moodEmoji;
                  delete taskItem.completedOnDate;
                  delete taskItem.completionNote;
                  const moodIndicator = li.querySelector(
                    ".task-mood-indicator"
                  );
                  if (moodIndicator) {
                    moodIndicator.remove();
                  }

                  // If this is a carried-forward task, handle uncompletion
                  if (taskItem.isCarriedForward && taskItem.originalDate) {
                    await handleCarriedForwardTaskUncompletion(taskItem);
                  }
                }

                await saveTasksToFirestore(
                  selectedDate,
                  analyzedTaskDataForSelectedDate
                );
              });

              // Abort task icon
              const abortIcon = document.createElement("i");
              abortIcon.classList.add("fas", "fa-times", "task-abort-icon");
              abortIcon.title = "Abort this task";
              abortIcon.addEventListener("click", async (e) => {
                e.stopPropagation();

                // Abort task silently without confirmation popup
                try {
                  // Find and remove the task from the data structure
                  const categoryKey = categoryKeyFromMap;
                  const tasksInCategory =
                    analyzedTaskDataForSelectedDate[categoryKey];

                  if (tasksInCategory && Array.isArray(tasksInCategory)) {
                    const taskIndex = tasksInCategory.findIndex(
                      (task) =>
                        task.task === taskItem.task &&
                        task.emoji === taskItem.emoji
                    );

                    if (taskIndex !== -1) {
                      // Remove the task completely from the array
                      tasksInCategory.splice(taskIndex, 1);
                    }
                  }

                  // Remove from UI immediately
                  li.remove();

                  // Update progress bar and dashboard
                  updateOverallProgressBar();
                  updateDashboardUI();

                  // Save updated data to database
                  await saveTasksToFirestore(
                    selectedDate,
                    analyzedTaskDataForSelectedDate
                  );

                  // If this is a carried-forward task, handle abortion properly
                  if (taskItem.isCarriedForward && taskItem.originalDate) {
                    await handleCarriedForwardTaskAbortion(taskItem);
                  }

                  // Task aborted silently
                } catch (error) {
                  console.error("Error aborting task:", error);
                  // Error handled silently
                }
              });

              taskActions.appendChild(tickIcon);
              taskActions.appendChild(abortIcon);
              mainContentDiv.appendChild(taskActions);
              li.appendChild(mainContentDiv);

              // Enhanced reason with priority indicators
              if (taskItem.reason) {
                const reasonDiv = document.createElement("div");
                reasonDiv.classList.add("task-reason");
                reasonDiv.textContent = taskItem.reason;
                li.appendChild(reasonDiv);
              }

              // Carry forward counter
              if (taskItem.isCarriedForward && taskItem.carryForwardCount) {
                const carryCountDiv = document.createElement("div");
                carryCountDiv.classList.add("carry-forward-count");
                // carryForwardCount 1 means 2nd time (original + 1 carry forward)
                const totalTimes = taskItem.carryForwardCount + 1;
                const ordinal = getOrdinal(totalTimes);
                carryCountDiv.textContent = ` ${ordinal} time running this task`;
                li.appendChild(carryCountDiv);
              }

              // Completion message for completed tasks
              if (taskItem.completed && taskItem.completionNote) {
                const completionDiv = document.createElement("div");
                completionDiv.classList.add("task-completion-note");
                completionDiv.textContent = ` ${taskItem.completionNote}`;
                li.appendChild(completionDiv);
              }

              // Enhanced meta section with priority score and confidence
              const metaDiv = document.createElement("div");
              metaDiv.classList.add("task-meta");
              const creationDateSpan = document.createElement("span");
              creationDateSpan.classList.add("task-creation-date");
              creationDateSpan.textContent = formatDateForDisplay(selectedDate);

              // Priority indicators (if available)
              const priorityIndicatorsDiv = document.createElement("div");
              priorityIndicatorsDiv.classList.add("task-priority-indicators");
              if (taskItem.priority_score) {
                const scoreSpan = document.createElement("span");
                scoreSpan.classList.add("priority-score");
                scoreSpan.textContent = `P${taskItem.priority_score}`;
                scoreSpan.title = `Priority Score: ${taskItem.priority_score}/10`;
                priorityIndicatorsDiv.appendChild(scoreSpan);
              }
              if (taskItem.confidence) {
                const confidenceSpan = document.createElement("span");
                confidenceSpan.classList.add("confidence-score");
                confidenceSpan.textContent = `C${taskItem.confidence}`;
                confidenceSpan.title = `AI Confidence: ${taskItem.confidence}/10`;
                priorityIndicatorsDiv.appendChild(confidenceSpan);
              }

              const assigneePlaceholder = document.createElement("div");
              assigneePlaceholder.classList.add("task-assignee-placeholder");
              assigneePlaceholder.textContent = yourname
                .substring(0, 1)
                .toUpperCase();

              metaDiv.appendChild(creationDateSpan);
              if (priorityIndicatorsDiv.children.length > 0)
                metaDiv.appendChild(priorityIndicatorsDiv);
              metaDiv.appendChild(assigneePlaceholder);
              li.appendChild(metaDiv);
              ui.listEl.appendChild(li);
            });
          }
          ui.quoteEl.textContent =
            quote || "Keep crushing those goals! You're doing great!";
        });
        updateDashboardUI();
        updateOverallProgressBar(); // Update overall progress bar after rendering tasks
        // AOS removed for better performance
        // Safe task tilt initialization
        function initializeTaskTiltEffects() {
          try {
            if (typeof $ === "undefined" || typeof $.fn.tilt !== "function") {
              return;
            }

            setTimeout(() => {
              try {
                const taskTiltElements = $(".task-column li[data-tilt]");
                if (taskTiltElements.length > 0) {
                  // Destroy existing instances
                  taskTiltElements.each(function () {
                    if ($(this).data("tilt")) {
                      $(this).tilt("destroy");
                    }
                  });

                  // Initialize new instances
                  taskTiltElements.tilt({
                    maxTilt: 2.5,
                    perspective: 800,
                    speed: 350,
                    glare: true,
                    maxGlare: 0.03,
                    reset: true,
                    "reset-to-start": false,
                  });
                  console.log(
                    `Task tilt effects initialized on ${taskTiltElements.length} elements`
                  );
                }
              } catch (innerError) {
                console.error("Inner task tilt error:", innerError);
              }
            }, 50);
          } catch (error) {
            console.error("Error initializing task tilt effects:", error);
          }
        }

        initializeTaskTiltEffects();
      }

      // --- Overall Progress Bar Updates ---
      function updateOverallProgressBar() {
        const overallProgressFill = document.getElementById(
          "overall-progress-fill"
        );
        const overallProgressText = document.getElementById(
          "overall-progress-text"
        );

        if (!overallProgressFill || !overallProgressText) return;

        let totalTasks = 0;
        let completedTasks = 0;

        if (analyzedTaskDataForSelectedDate) {
          Object.keys(categoryUiMap).forEach((categoryKey) => {
            const tasksInCategory =
              analyzedTaskDataForSelectedDate[categoryKey];
            if (Array.isArray(tasksInCategory)) {
              // Aborted tasks are now completely removed, so no need to filter
              totalTasks += tasksInCategory.length;
              completedTasks += tasksInCategory.filter(
                (task) => task.completed
              ).length;
            }
          });
        }

        const percentage =
          totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

        // Update progress bar with smooth animation
        overallProgressFill.style.width = `${percentage}%`;

        // Update text with detailed information
        overallProgressText.textContent = `${completedTasks}/${totalTasks} tasks completed (${percentage}%)`;

        // Add visual feedback for completion milestones
        const progressContainer = document.getElementById(
          "overall-progress-container"
        );
        if (progressContainer) {
          progressContainer.classList.remove(
            "milestone-25",
            "milestone-50",
            "milestone-75",
            "milestone-100"
          );

          if (percentage >= 100) {
            progressContainer.classList.add("milestone-100");
          } else if (percentage >= 75) {
            progressContainer.classList.add("milestone-75");
          } else if (percentage >= 50) {
            progressContainer.classList.add("milestone-50");
          } else if (percentage >= 25) {
            progressContainer.classList.add("milestone-25");
          }
        }
      }

      // --- Task Behavioural Analysis Logic ---
      if (toggleBehaviourAnalysisBtn) {
        toggleBehaviourAnalysisBtn.addEventListener("click", () => {
          const isBehaviourHidden =
            taskBehaviouralAnalysisSection.classList.contains("hidden");
          const sectionToHide = isBehaviourHidden
            ? taskColumnsContainer
            : taskBehaviouralAnalysisSection;
          const sectionToShow = isBehaviourHidden
            ? taskBehaviouralAnalysisSection
            : taskColumnsContainer;
          gsap.to(sectionToHide, {
            opacity: 0,
            duration: 0.25,
            onComplete: () => {
              sectionToHide.classList.add("hidden");
              sectionToShow.classList.remove("hidden");
              gsap.fromTo(
                sectionToShow,
                { opacity: 0, y: 15 },
                { opacity: 1, y: 0, duration: 0.3, ease: "power2.out" }
              );
              if (isBehaviourHidden) loadAndDisplayBehaviouralAnalysis();
              // AOS removed for better performance
            },
          });
        });
      }
      if (backToTasksFromBehaviourBtn) {
        backToTasksFromBehaviourBtn.addEventListener("click", () => {
          gsap.to(taskBehaviouralAnalysisSection, {
            opacity: 0,
            y: 15,
            duration: 0.25,
            ease: "power2.in",
            onComplete: () => {
              taskBehaviouralAnalysisSection.classList.add("hidden");
              taskColumnsContainer.classList.remove("hidden");
              gsap.fromTo(
                taskColumnsContainer,
                { opacity: 0 },
                { opacity: 1, duration: 0.3, ease: "power2.out" }
              );
              // AOS removed for better performance
            },
          });
        });
      }

      function loadAndDisplayBehaviouralAnalysis() {
        showLoading(true);
        if (!analyzedTaskDataForSelectedDate) {
          behaviourCompletionRateEl.textContent = "0%";
          behaviourCompletionProgressBarEl.style.width = "0%";
          focusCategoryBehaviourEl.textContent = "-";
          const avgPriorityEl = document.getElementById(
            "avg-priority-score-behaviour"
          );
          const avgConfidenceEl = document.getElementById(
            "avg-confidence-behaviour"
          );
          if (avgPriorityEl) avgPriorityEl.textContent = "-";
          if (avgConfidenceEl) avgConfidenceEl.textContent = "-";
          renderCompletionByCategoryChart({});
          showLoading(false);
          return;
        }

        let totalCreated = 0,
          totalCompleted = 0;
        let totalPriorityScore = 0,
          totalConfidence = 0,
          tasksWithScores = 0;
        const categoryCounts = {};
        const categoryCompletedCounts = {};

        Object.keys(categoryUiMap).forEach((categoryKey) => {
          categoryCounts[categoryKey] = 0;
          categoryCompletedCounts[categoryKey] = 0;
          const tasksInCategory = analyzedTaskDataForSelectedDate[categoryKey];
          if (tasksInCategory && Array.isArray(tasksInCategory)) {
            tasksInCategory.forEach((task) => {
              if (task && typeof task === "object" && "task" in task) {
                totalCreated++;
                categoryCounts[categoryKey]++;
                if (task.completed) {
                  totalCompleted++;
                  categoryCompletedCounts[categoryKey]++;
                }

                // Calculate priority and confidence averages
                if (
                  task.priority_score &&
                  typeof task.priority_score === "number"
                ) {
                  totalPriorityScore += task.priority_score;
                  tasksWithScores++;
                }
                if (task.confidence && typeof task.confidence === "number") {
                  totalConfidence += task.confidence;
                }
              }
            });
          }
        });

        // Update completion metrics
        const completionPercentage =
          totalCreated > 0
            ? Math.round((totalCompleted / totalCreated) * 100)
            : 0;
        behaviourCompletionRateEl.textContent = `${completionPercentage}%`;
        behaviourCompletionProgressBarEl.style.width = `${completionPercentage}%`;

        // Update priority and confidence metrics
        const avgPriorityEl = document.getElementById(
          "avg-priority-score-behaviour"
        );
        const avgConfidenceEl = document.getElementById(
          "avg-confidence-behaviour"
        );
        if (avgPriorityEl) {
          const avgPriority =
            tasksWithScores > 0
              ? (totalPriorityScore / tasksWithScores).toFixed(1)
              : "-";
          avgPriorityEl.textContent =
            avgPriority !== "-" ? `${avgPriority}/10` : "-";
        }
        if (avgConfidenceEl) {
          const avgConfidence =
            totalCreated > 0
              ? (totalConfidence / totalCreated).toFixed(1)
              : "-";
          avgConfidenceEl.textContent =
            avgConfidence !== "-" ? `${avgConfidence}/10` : "-";
        }

        // Update focus category
        let maxTasks = -1;
        let focusCat = "-";
        for (const cat in categoryCounts) {
          if (categoryCounts[cat] > maxTasks) {
            maxTasks = categoryCounts[cat];
            focusCat = cat.replace(" Tasks", ""); // Clean up category name
          }
        }
        focusCategoryBehaviourEl.textContent = focusCat;
        const chartData = {
          labels: Object.keys(categoryCounts),
          datasets: [
            {
              label: "Tasks Created",
              data: Object.values(categoryCounts),
              backgroundColor: [
                "rgba(123, 160, 201, 0.6)",
                "rgba(212, 132, 132, 0.6)",
                "rgba(230, 197, 127, 0.6)",
                "rgba(169, 138, 190, 0.6)",
              ],
              borderColor: ["#7BA0C9", "#D48484", "#E6C57F", "#A98ABE"],
              borderWidth: 1,
            },
            {
              label: "Tasks Completed",
              data: Object.values(categoryCompletedCounts),
              backgroundColor: [
                "rgba(91, 130, 171, 0.6)",
                "rgba(195, 102, 102, 0.6)",
                "rgba(215, 175, 97, 0.6)",
                "rgba(145, 110, 165, 0.6)",
              ],
              borderColor: ["#5B82AB", "#C36666", "#D7AF61", "#916EA5"],
              borderWidth: 1,
            },
          ],
        };
        renderCompletionByCategoryChart(chartData);
        renderMoodAnalyticsChart(); // Add mood analytics chart
        showLoading(false);
      }

      function renderCompletionByCategoryChart(data) {
        const ctx = document
          .getElementById("completionByCategoryChart")
          ?.getContext("2d");
        if (!ctx) {
          console.error("completionByCategoryChart canvas not found");
          return;
        }
        if (completionByCategoryChartInstance)
          completionByCategoryChartInstance.destroy();

        const isMobile = window.innerWidth < 768;

        completionByCategoryChartInstance = new Chart(ctx, {
          type: "bar",
          data: data,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  color: "var(--ph-new-text-medium)",
                  stepSize: 1,
                  font: { family: "Poppins", size: isMobile ? 8 : 10 },
                },
                grid: { color: "var(--ph-new-border-color)" },
              },
              x: {
                ticks: {
                  color: "var(--ph-new-text-medium)",
                  font: { family: "Poppins", size: isMobile ? 8 : 10 },
                  autoSkip: true,
                  maxRotation: isMobile ? 70 : 45,
                  minRotation: isMobile ? 45 : 30,
                  padding: 5,
                },
                grid: { display: false },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: "var(--ph-new-text-dark)",
                  font: { size: isMobile ? 9 : 11, family: "Poppins" },
                },
              },
              tooltip: {
                backgroundColor: "var(--ph-new-white)",
                titleColor: "var(--ph-new-text-dark)",
                bodyColor: "var(--ph-new-text-medium)",
                borderColor: "var(--ph-new-border-color)",
                borderWidth: 1,
                titleFont: { family: "Poppins" },
                bodyFont: { family: "Poppins" },
              },
            },
            animation: { duration: 700, easing: "easeOutQuart" },
          },
        });
      }

      // --- Authentication Management ---
      function checkAuthState() {
        const authLoadingScreen = document.getElementById("auth-loading");

        console.log("Starting authentication check...");

        // Set a timeout to prevent infinite loading
        const authTimeout = setTimeout(() => {
          console.log(
            "Authentication check timeout, redirecting to landing page"
          );
          authCheckComplete = true;
          window.location.replace("landingpage.html");
        }, 8000); // 8 second timeout

        onAuthStateChanged(
          auth,
          async (user) => {
            // Clear the timeout since we got a response
            clearTimeout(authTimeout);
            authCheckComplete = true;

            if (user) {
              // User is signed in
              currentUser = user;
              console.log("User authenticated successfully:", user.email);

              // Load completed tasks tracker for this user
              loadCompletedTasksTracker();
              // Clean up old entries
              cleanupCompletedTasksTracker();

              // Hide auth loading screen with a small delay to ensure smooth transition
              setTimeout(async () => {
                if (authLoadingScreen) {
                  authLoadingScreen.style.display = "none";
                }

                // Show the main app
                const mainLayout = document.querySelector(".main-app-layout");
                if (mainLayout) {
                  mainLayout.style.display = "flex";
                  console.log("Main app layout displayed");
                }

                // Initialize the app
                try {
                  initializePriorityHelpApp();
                  console.log("App initialization completed");

                  // Load username first
                  await loadUserDisplayName();

                  // Load current streak
                  await loadCurrentStreak();

                  // Check if username setup is needed
                  if (checkIfUsernameNeeded()) {
                    // Show simple prompt for username setup
                    setTimeout(() => {
                      showUsernameSetupPrompt();
                    }, 500);
                  }
                } catch (error) {
                  console.error("Error initializing app:", error);
                }
              }, 100);
            } else {
              // User is signed out
              currentUser = null;
              console.log(
                "User not authenticated, redirecting to landing page"
              );

              // Immediate redirect to landing page
              window.location.replace("landingpage.html");
            }
          },
          (error) => {
            // Handle authentication errors
            console.error("Authentication error:", error);
            clearTimeout(authTimeout);
            authCheckComplete = true;
            window.location.replace("landingpage.html");
          }
        );
      }

      async function handleLogout() {
        try {
          await signOut(auth);
          console.log("User signed out successfully");
        } catch (error) {
          console.error("Error signing out:", error);
          // Logout error handled silently
        }
      }

      // --- Initialization ---
      function initializePriorityHelpApp() {
        console.log(
          "Initializing PriorityHelp AI (Plantitas UI Edition - Final Update)..."
        );
        // Basic check for actual keys (length based, adjust if your keys are very short)
        if (GEMINI_API_KEY.startsWith("AIzaSy") && GEMINI_API_KEY.length < 25) {
          console.warn(
            "Gemini API Key potentially missing - check configuration"
          );
        }
        if (
          firebaseConfig.apiKey.startsWith("AIzaSy") &&
          firebaseConfig.apiKey.length < 25
        ) {
          console.warn(
            "Firebase API Key potentially missing - check configuration"
          );
        }

        // Initialize modals with proper CSS classes instead of GSAP visibility conflicts
        taskInputModalEl.classList.add("hidden");
        taskInputModalEl.classList.remove("visible");
        gsap.set(taskModalContentEl, { y: 25, scale: 0.96, opacity: 0 });

        infoModalEl.classList.add("hidden");
        infoModalEl.classList.remove("visible");
        gsap.set(infoModalContentEl, { y: 25, scale: 0.96, opacity: 0 });

        updateDateDisplayAndLoadTasks();
        initAnimations();
        addTouchSupport(); // Initialize touch support for mobile

        // Initialize simple username functionality
        initializeNameDropdown();

        // Initialize carry forward functionality
        if (addPreviousTasksBtn) {
          addPreviousTasksBtn.addEventListener(
            "click",
            addPreviousIncompleteTasks
          );
        }

        // Initialize fetch again functionality
        if (fetchAgainBtn) {
          fetchAgainBtn.addEventListener("click", async () => {
            await checkAndShowCarryForward();
          });
        }

        console.log(
          "PriorityHelp AI Initialized with enhanced UX features! "
        );
      }

      function init() {
        console.log("Starting PriorityHelp AI initialization...");

        // Hide main app initially until authentication is verified
        const mainLayout = document.querySelector(".main-app-layout");
        if (mainLayout) {
          mainLayout.style.display = "none";
        }

        // Show authentication loading screen
        const authLoadingScreen = document.getElementById("auth-loading");
        if (authLoadingScreen) {
          authLoadingScreen.style.display = "flex";
        }

        // Check authentication state
        checkAuthState();
      }

      // --- Event Listeners for New Features ---

      // Focus Mode Event Listeners
      if (focusModeBtn)
        focusModeBtn.addEventListener("click", openFocusModeModal);
      if (focusModeCloseBtn)
        focusModeCloseBtn.addEventListener("click", closeFocusModeModal);
      if (focusStartBtn)
        focusStartBtn.addEventListener("click", startFocusMode);
      if (focusPauseBtn)
        focusPauseBtn.addEventListener("click", pauseFocusMode);
      if (focusResetBtn)
        focusResetBtn.addEventListener("click", resetFocusMode);

      // Mood Selection Event Listeners
      if (skipMoodBtn)
        skipMoodBtn.addEventListener("click", closeMoodSelection);

      // Add event listeners to mood options
      document.querySelectorAll(".mood-option").forEach((option) => {
        option.addEventListener("click", () => {
          const mood = option.dataset.mood;
          const emoji = option.dataset.emoji;
          selectMood(mood, emoji);
        });
      });

      // Profile event listeners moved to initializeProfileEventListeners() function

      // Close modals when clicking outside
      if (focusModeModal) {
        focusModeModal.addEventListener("click", (e) => {
          if (e.target === focusModeModal) {
            closeFocusModeModal();
          }
        });
      }

      if (moodSelectionModal) {
        moodSelectionModal.addEventListener("click", (e) => {
          if (e.target === moodSelectionModal) {
            closeMoodSelection();
          }
        });
      }

      // Profile modal outside click listener moved to initializeProfileEventListeners() function

      // Global error handler for tilt library issues
      window.addEventListener("error", function (e) {
        if (e.filename && e.filename.includes("tilt.jquery.min.js")) {
          console.warn("Tilt library error caught and suppressed:", e.message);
          e.preventDefault();
          return false;
        }
      });

      // Additional error handling for jQuery tilt
      if (typeof $ !== "undefined") {
        $(document).on("error", function (e) {
          if (
            e.originalEvent &&
            e.originalEvent.filename &&
            e.originalEvent.filename.includes("tilt.jquery.min.js")
          ) {
            console.warn("jQuery tilt error caught:", e.originalEvent.message);
            e.preventDefault();
            return false;
          }
        });
      }

      init();
    </script>
  </body>
</html>
